<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HoopsLink - Find Your Game</title>
  <!-- Include Supabase JS Library (v2) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    /* --- Global Styles & Variables --- */
    :root {
      --primary-color: #ff6b00; /* Energetic Orange */
      --secondary-color: #4a00e0; /* Vibrant Purple */
      --accent-color: #00f2a9; /* Electric Teal */
      --background-color: #121212; /* Dark Background */
      --surface-color: #1e1e1e; /* Slightly Lighter Surface */
      --text-color: #e0e0e0; /* Light Text */
      --text-color-dark: #111111; /* Dark Text for light backgrounds */
      --success-color: #00d18b;
      --error-color: #ff4d4d;
      --font-family: 'Poppins', sans-serif; /* Playful but clean font */
      --border-radius: 12px;
      --box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      --transition-speed: 0.3s;
      --transition-effect: ease-in-out;
    }

    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;900&display=swap');

    /* Make all text non-selectable */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    /* Allow selection in input and textarea */
    input, textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    /* Remove any stray content from html::before */
    html::before {
      content: "";
      display: none;
    }

    html {
      height: 100%;
    }

    body {
      min-height: 100%;
      font-family: var(--font-family);
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color)) fixed;
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      font-size: 16px;
    }

    #app-container {
      width: 100%;
      max-width: 900px;
      min-height: 600px;
      height: auto;
      max-height: 95vh;
      background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      margin: auto;
    }

    /* --- Screen Management --- */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--background-color);
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-speed) var(--transition-effect), transform var(--transition-speed) var(--transition-effect);
      transform: translateX(100%);
      display: flex;
      flex-direction: column;
      z-index: 1;
    }
    .screen.active {
      opacity: 1;
      visibility: visible;
      transform: translateX(0);
      z-index: 10;
    }
    /* Specific screen transitions */
    #auth-screen.active { transform: translateX(0); }
    #loading-screen.active { transform: scale(1); opacity: 1; z-index: 100; }
    #main-app-screen.active { transform: translateX(0); }
    #game-detail-screen.active { transform: translateX(0); }
    #active-game-screen.active { transform: scale(1); opacity: 1; }
    #game-end-screen.active { transform: translateY(0); opacity: 1; }
    #profile-screen.active { transform: translateX(0); }
    #leaderboard-screen.active { transform: translateX(0); }

    #loading-screen {
      transform: scale(1.1);
      transition: opacity var(--transition-speed) ease-out, transform var(--transition-speed) ease-out;
      background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    #game-end-screen {
      transform: translateY(100%);
    }

    /* --- Utility Classes --- */
    .hidden { display: none !important; }
    .text-center { text-align: center; }
    .bold { font-weight: bold; }
    .primary-text { color: var(--primary-color); }
    .secondary-text { color: var(--secondary-color); }
    .accent-text { color: var(--accent-color); }
    .error-text { color: var(--error-color); font-size: 0.9em; margin-top: 5px; }
    .success-text { color: var(--success-color); }
    .flex-col { display: flex; flex-direction: column; }
    .flex-row { display: flex; flex-direction: row; }
    .flex-center { display: flex; justify-content: center; align-items: center; }
    .flex-grow { flex-grow: 1; }
    .space-between { justify-content: space-between; }
    .align-center { align-items: center; }
    .p-1 { padding: 1rem; }
    .p-2 { padding: 2rem; }
    .m-1 { margin: 1rem; }
    .mt-1 { margin-top: 1rem; }
    .mb-1 { margin-bottom: 1rem; }
    .ml-1 { margin-left: 1rem; }
    .mr-1 { margin-right: 1rem; }
    .gap-1 { gap: 1rem; }
    .gap-05 { gap: 0.5rem; }
    .w-full { width: 100%; }

    /* --- Basic Elements Styling --- */
    button, input[type="submit"] {
      padding: 12px 25px;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: transform var(--transition-speed) var(--transition-effect), background-color var(--transition-speed) var(--transition-effect), box-shadow var(--transition-speed) var(--transition-effect);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    button::before, input[type="submit"]::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.5s ease-out, height 0.5s ease-out;
      z-index: -1;
    }
    button:active::before, input[type="submit"]:active::before {
      width: 300px;
      height: 300px;
    }
    button:hover, input[type="submit"]:hover {
      transform: translateY(-3px) scale(1.03);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }
    button:active, input[type="submit"]:active {
      transform: translateY(0) scale(1);
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
    }
    .btn-primary {
      background: linear-gradient(45deg, var(--primary-color), #ffa040);
      color: var(--text-color-dark);
    }
    .btn-secondary {
      background: linear-gradient(45deg, var(--secondary-color), #8a2be2);
      color: var(--text-color);
    }
    .btn-accent {
      background: linear-gradient(45deg, var(--accent-color), #00c896);
      color: var(--text-color-dark);
    }
    .btn-danger {
      background: linear-gradient(45deg, var(--error-color), #ff6f6f);
      color: var(--text-color);
    }
    .btn-outline {
      background-color: transparent;
      border: 2px solid var(--primary-color);
      color: var(--primary-color);
    }
    .btn-outline:hover {
      background-color: var(--primary-color);
      color: var(--text-color-dark);
    }
    input[type="text"], input[type="email"], input[type="password"], input[type="datetime-local"], textarea {
      width: 100%;
      padding: 12px 15px;
      background-color: var(--surface-color);
      border: 1px solid transparent;
      border-radius: var(--border-radius);
      color: var(--text-color);
      font-size: 1rem;
      transition: border-color var(--transition-speed) var(--transition-effect), box-shadow var(--transition-speed);
    }
    input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus, input[type="datetime-local"]:focus, textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(255, 107, 0, 0.3);
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: var(--accent-color);
    }
    h1, h2, h3 {
      font-weight: 700;
      margin-bottom: 1rem;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    h1 {
      font-size: 2.5rem;
      line-height: 1.1;
      background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
      -webkit-background-clip: text;
      color: transparent;
      font-weight: 900;
    }
    h2 { font-size: 1.8rem; color: var(--primary-color); }
    h3 { font-size: 1.4rem; color: var(--secondary-color); }
    hr {
      border: none;
      height: 1px;
      background-color: var(--surface-color);
      margin: 1rem 0;
    }

    /* --- Header / Navbar --- */
    .app-header {
      padding: 1rem;
      background-color: var(--surface-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      z-index: 50;
      position: sticky;
      top: 0;
      border-top-left-radius: var(--border-radius);
      border-top-right-radius: var(--border-radius);
    }
    .app-header .logo {
      font-size: 1.5rem;
      font-weight: 900;
      background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
      -webkit-background-clip: text;
      color: transparent;
      cursor: pointer;
      animation: pulse-logo 5s infinite ease-in-out;
    }
    @keyframes pulse-logo {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .header-actions button {
      background: none;
      border: none;
      color: var(--accent-color);
      font-size: 1.5rem;
      cursor: pointer;
      margin-left: 1rem;
      padding: 5px;
      transition: color var(--transition-speed), transform var(--transition-speed);
    }
    .header-actions button:hover {
      color: var(--primary-color);
      transform: scale(1.1);
    }

    /* --- Content Area --- */
    .screen > .content-area {
      flex-grow: 1;
      overflow-y: auto;
      padding: 1rem;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--surface-color);
    }
    .screen > .content-area::-webkit-scrollbar {
      width: 8px;
    }
    .screen > .content-area::-webkit-scrollbar-track {
      background: var(--surface-color);
      border-radius: 10px;
    }
    .screen > .content-area::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 10px;
      border: 2px solid var(--surface-color);
    }

    /* --- Loading Spinner --- */
    .loader {
      border: 6px solid var(--surface-color);
      border-top: 6px solid var(--primary-color);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin: 2rem auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* --- Specific Screen Styles --- */

    /* Auth Screen */
    #auth-screen {
      background: linear-gradient(180deg, var(--secondary-color) 0%, var(--background-color) 70%);
      justify-content: center;
      align-items: center;
      padding: 2rem;
      height: 100%;
    }
    #auth-form-container {
      background-color: rgba(30, 30, 30, 0.8);
      padding: 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      width: 100%;
      max-width: 380px;
      backdrop-filter: blur(5px);
      margin: auto;
    }
    #auth-form-container h2 {
      color: var(--accent-color);
      text-align: center;
      margin-bottom: 1.5rem;
    }
    .auth-toggle {
      margin-top: 1rem;
      text-align: center;
    }
    .auth-toggle button {
      background: none;
      border: none;
      color: var(--primary-color);
      text-decoration: underline;
      font-size: 0.9rem;
      cursor: pointer;
    }

    /* Main App Screen (Game List) */
    #main-app-screen > .content-area { padding: 0; }
    #game-list {
      list-style: none;
      padding: 1rem 0;
    }
    .game-list-item {
      background-color: var(--surface-color);
      margin: 1rem;
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      border-left: 5px solid var(--primary-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: transform var(--transition-speed), box-shadow var(--transition-speed), border-color var(--transition-speed);
      animation: slideInUp 0.5s var(--transition-effect) backwards;
      opacity: 0;
    }
    @keyframes slideInUp {
      from { transform: translateY(50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .game-list-item:hover {
      transform: translateX(5px) scale(1.02);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      border-left-color: var(--accent-color);
    }
    .game-info h3 { margin-bottom: 0.3rem; color: var(--text-color); font-size: 1.2rem; }
    .game-meta { font-size: 0.9rem; color: #aaa; }
    .game-status-indicator {
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: bold;
      text-transform: uppercase;
    }
    .status-pending { background-color: var(--primary-color); color: var(--text-color-dark); }
    .status-active { background-color: var(--success-color); color: var(--text-color-dark); }
    .status-finished { background-color: var(--secondary-color); color: var(--text-color); }
    #create-game-fab {
      position: absolute;
      bottom: 2rem;
      right: 2rem;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
      color: var(--text-color-dark);
      font-size: 2rem;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      z-index: 20;
      transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    #create-game-fab:hover {
      transform: scale(1.1) rotate(90deg);
    }

    /* Create Game Modal */
    #create-game-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease;
      backdrop-filter: blur(5px);
    }
    #create-game-modal.visible {
      opacity: 1;
      visibility: visible;
    }
    #create-game-form-container {
      background-color: var(--surface-color);
      padding: 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      width: 90%;
      max-width: 450px;
      transform: scale(0.9);
      transition: transform var(--transition-speed) cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    #create-game-modal.visible #create-game-form-container {
      transform: scale(1);
    }

    /* Game Detail / Lobby Screen */
    #game-detail-screen > .content-area,
    #active-game-screen > .content-area {
      padding: 1.5rem;
    }
    #game-detail-header h2 {
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      color: transparent;
      margin-bottom: 0.5rem;
    }
    #game-detail-meta span { margin-right: 1rem; color: #ccc; font-size: 0.9rem; }
    #player-list { list-style: none; padding: 0; }
    .player-list-item {
      background-color: var(--surface-color);
      padding: 10px 15px;
      border-radius: var(--border-radius);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      animation: fadeIn 0.5s ease forwards;
      opacity: 0;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .player-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: var(--secondary-color);
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: var(--text-color);
    }
    .player-username { font-weight: 600; }
    .player-status { margin-left: auto; font-size: 0.8rem; color: #aaa; }
    #game-actions { max-width: 300px; margin: 1rem auto 0 auto; }
    #game-actions button { width: 100%; margin-top: 10px; }
    #game-detail-error { text-align: center; }

    /* Active Game Screen */
    #active-game-screen {
      background: linear-gradient(180deg, #222 0%, var(--background-color) 80%);
    }
    .scoreboard {
      display: flex;
      justify-content: space-around;
      align-items: center;
      background-color: rgba(0,0,0,0.3);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin-bottom: 1.5rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    .team-score { text-align: center; }
    .team-name { font-size: 1rem; font-weight: 600; margin-bottom: 5px; color: #aaa; }
    .score {
      font-size: 3rem;
      font-weight: 900;
      line-height: 1;
      transition: transform 0.3s ease, color 0.3s ease;
      cursor: pointer;
    }
    .score:hover { transform: scale(1.1); }
    #team-a-score { color: var(--primary-color); }
    #team-b-score { color: var(--accent-color); }
    .vs { font-size: 1.5rem; font-weight: bold; color: var(--text-color); }
    .team-display {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }
    .team-column {
      flex: 1;
      background-color: var(--surface-color);
      padding: 1rem;
      border-radius: var(--border-radius);
    }
    .team-column h4 { margin-bottom: 1rem; text-align: center; }
    #team-a-list h4 { color: var(--primary-color); }
    #team-b-list h4 { color: var(--accent-color); }
    .team-player {
      font-size: 0.9rem;
      padding: 5px 0;
      border-bottom: 1px solid #333;
    }
    .team-player:last-child { border-bottom: none; }
    #score-confirmation-modal {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--surface-color);
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      z-index: 1001;
      display: flex;
      align-items: center;
      gap: 1rem;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
      transform: translate(-50%, 20px);
    }
    #score-confirmation-modal.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%);
    }
    #score-confirmation-modal button {
      padding: 8px 15px;
      font-size: 0.9rem;
    }

    /* Game End Screen */
    #game-end-screen {
      background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 100%);
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem;
      position: relative;
      overflow: hidden;
    }
    #game-end-summary {
      background-color: rgba(30, 30, 30, 0.8);
      padding: 2.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      backdrop-filter: blur(5px);
      animation: zoomIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      opacity: 0;
      max-width: 500px;
      width: 90%;
    }
    @keyframes zoomIn {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    #game-end-summary h2 { color: var(--accent-color); font-size: 2.5rem; }
    #final-score { font-size: 1.8rem; margin-bottom: 1.5rem; }
    #mvp-highlight {
      background-color: rgba(0,0,0,0.3);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin-bottom: 1.5rem;
      border: 2px solid var(--accent-color);
    }
    #mvp-highlight h3 { color: var(--accent-color); margin-bottom: 0.5rem; font-size: 1.2rem; }
    #mvp-username { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
    #mvp-score { font-size: 1rem; color: #ccc; }
    #game-end-actions button { margin: 0.5rem; }

    /* Confetti */
    .confetti {
      position: absolute;
      width: 10px;
      height: 20px;
      background-color: var(--primary-color);
      opacity: 0.7;
      animation: confetti-fall 4s linear infinite;
      pointer-events: none;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-100px) rotateZ(0deg); opacity: 0.7; }
      100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0; }
    }
    #confetti-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 0;
    }

    /* Profile Screen */
    #profile-screen > .content-area { padding: 2rem; }
    #profile-header { text-align: center; margin-bottom: 2rem; }
    #profile-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      margin: 0 auto 1rem auto;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 4rem;
      font-weight: bold;
      color: var(--text-color);
      box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
    }
    #profile-username { font-size: 1.8rem; font-weight: bold; }
    /* Hide the username input by default */
    #edit-profile-username-input { display: none; margin-top: 5px; max-width: 250px; margin-left: auto; margin-right: auto; }
    #edit-profile-btn, #save-profile-btn {
      background: none; border: none; color: var(--accent-color); cursor: pointer; font-size: 0.9rem; margin-left: 10px;
    }
    #profile-stats {
      background-color: var(--surface-color);
      padding: 1.5rem;
      border-radius: var(--border-radius);
      margin-top: 1.5rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .stat-item { text-align: center; }
    .stat-value { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
    .stat-label { font-size: 0.9rem; color: #aaa; }

    /* Game History */
    #game-history-list { margin-top: 1.5rem; list-style: none; padding: 0; max-width: 700px; margin-left: auto; margin-right: auto; }
    .history-item {
      background-color: var(--surface-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin-bottom: 1rem;
      border-left: 4px solid var(--secondary-color);
    }
    .history-details { font-size: 0.9em; color: #ccc; margin-bottom: 5px; }
    .history-score { font-weight: bold; }
    .history-result { font-weight: bold; }
    .result-win { color: var(--success-color); }
    .result-loss { color: var(--error-color); }

    /* Leaderboard Screen */
    #leaderboard-screen > .content-area { padding: 0; }
    /* New leaderboard filter container */
    #leaderboard-filter {
      padding: 1rem;
      text-align: center;
    }
    #leaderboard-filter select {
      padding: 8px 12px;
      border-radius: var(--border-radius);
      border: 1px solid var(--surface-color);
      background-color: var(--surface-color);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    #leaderboard-list {
      list-style: none;
      padding: 1rem 0;
      max-width: 700px;
      margin: 0 auto;
    }
    .leaderboard-item {
      display: flex;
      align-items: center;
      padding: 1rem;
      margin: 0 1rem 1rem 1rem;
      background-color: var(--surface-color);
      border-radius: var(--border-radius);
      position: relative;
      transition: transform 0.2s ease-in-out;
      animation: fadeIn 0.5s ease forwards;
      opacity: 0;
    }
    .leaderboard-item:hover {
      transform: scale(1.03);
    }
    .leaderboard-rank {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--primary-color);
      width: 40px;
      text-align: center;
      margin-right: 1rem;
    }
    .leaderboard-item:nth-child(1) .leaderboard-rank { color: #ffd700; font-size: 1.6rem; }
    .leaderboard-item:nth-child(2) .leaderboard-rank { color: #c0c0c0; font-size: 1.4rem; }
    .leaderboard-item:nth-child(3) .leaderboard-rank { color: #cd7f32; font-size: 1.3rem; }
    .leaderboard-avatar {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background-color: var(--secondary-color);
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: var(--text-color);
      margin-right: 1rem;
    }
    .leaderboard-info { flex-grow: 1; }
    .leaderboard-username { font-weight: 600; }
    .leaderboard-stat { font-size: 0.9rem; color: #aaa; }
    .leaderboard-score {
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent-color);
    }

    /* Chat */
    #chat-drawer {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 350px;
      height: 60%;
      max-height: 450px;
      background-color: var(--surface-color);
      border-top-left-radius: var(--border-radius);
      border-bottom-left-radius: var(--border-radius);
      box-shadow: -10px 0 30px rgba(0,0,0,0.5);
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      z-index: 900;
      display: flex;
      flex-direction: column;
      padding: 1rem;
    }
    #chat-drawer.open {
      transform: translateX(0);
    }
    #chat-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #444; }
    #chat-header h3 { margin-bottom: 0; color: var(--accent-color); }
    #close-chat-btn { background: none; border: none; color: var(--text-color); font-size: 1.5rem; cursor: pointer; }
    #chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 1rem;
      scrollbar-width: thin;
      scrollbar-color: var(--secondary-color) var(--background-color);
    }
    #chat-messages::-webkit-scrollbar { width: 6px; }
    #chat-messages::-webkit-scrollbar-track { background: var(--background-color); border-radius: 10px; }
    #chat-messages::-webkit-scrollbar-thumb { background-color: var(--secondary-color); border-radius: 10px; }
    .chat-message {
      margin-bottom: 0.8rem;
      display: flex;
      flex-direction: column;
      max-width: 90%;
      animation: popIn 0.3s ease forwards;
      opacity: 0;
    }
    @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .chat-message.own { align-self: flex-end; align-items: flex-end; }
    .message-bubble {
      padding: 8px 12px;
      border-radius: var(--border-radius);
      background-color: #333;
      color: var(--text-color);
      word-wrap: break-word;
    }
    .chat-message.own .message-bubble {
      background: linear-gradient(45deg, var(--primary-color), #ffa040);
      color: var(--text-color-dark);
    }
    .message-meta {
      font-size: 0.75rem;
      color: #aaa;
      margin-top: 3px;
    }
    .chat-message.own .message-meta { text-align: right; }
    .message-sender { font-weight: bold; margin-right: 5px; }
    #chat-input-area { display: flex; gap: 10px; }
    #chat-input { flex-grow: 1; background-color: #444; border: none; }
    #chat-input:focus { box-shadow: none; border: 1px solid var(--secondary-color); }
    #send-chat-btn { }
    
    /* Modal Base */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease;
      backdrop-filter: blur(5px);
    }
    .modal.visible { opacity: 1; visibility: visible; }
    .modal-content {
      background-color: var(--surface-color);
      padding: 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      width: 90%;
      max-width: 450px;
      transform: scale(0.9);
      transition: transform var(--transition-speed) cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
    }
    .modal.visible .modal-content { transform: scale(1); }
    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 1.8rem;
      cursor: pointer;
      line-height: 1;
      padding: 5px;
    }

    /* Share Modal */
    #share-options button {
      display: block;
      width: 100%;
      margin-bottom: 10px;
      text-align: left;
      padding: 12px 15px;
      background-color: #444;
      color: var(--text-color);
    }
    #share-options button:hover {
      background-color: #555;
      transform: none;
      box-shadow: none;
    }
    #share-link-input { margin-top: 1rem; }
  </style>
</head>
<body>
  <div id="app-container">
    <!-- Loading Screen -->
    <div id="loading-screen" class="screen active">
      <h1 class="logo" style="font-size: 3rem; animation: pulse-logo 2s infinite ease-in-out;">HoopsLink</h1>
      <div class="loader mt-1"></div>
      <p class="mt-1">Finding your court...</p>
    </div>

    <!-- Auth Screen -->
    <div id="auth-screen" class="screen flex-col">
      <div id="auth-form-container">
        <h2 id="auth-title">Login to HoopsLink</h2>
        <form id="auth-form">
          <div class="mb-1">
            <label for="email">Email</label>
            <input type="email" id="email" required>
          </div>
          <div class="mb-1">
            <label for="password">Password</label>
            <input type="password" id="password" required>
          </div>
          <div id="username-field" class="mb-1 hidden">
            <label for="username">Username</label>
            <input type="text" id="username" minlength="3">
            <small style="font-size: 0.8em; color: #aaa;">Min 3 characters, used for display.</small>
          </div>
          <div id="auth-error" class="error-text mb-1"></div>
          <button type="submit" id="auth-submit-btn" class="btn-primary w-full">Login</button>
        </form>
        <div class="auth-toggle">
          <span id="auth-toggle-text">Don't have an account?</span>
          <button id="auth-toggle-btn">Sign Up</button>
        </div>
      </div>
    </div>

    <!-- Main App Screen (Game List) -->
    <div id="main-app-screen" class="screen flex-col">
      <header class="app-header">
        <div class="logo">HoopsLink</div>
        <div class="header-actions">
          <button id="leaderboard-nav-btn" title="Leaderboard">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
              <path d="M120-120v-150h150v150H120Zm0-270v-150h150v150H120Zm0-270v-150h150v150H120Zm270 270v-150h150v150H390Zm0-270v-150h150v150H390Zm270 540v-150h150v150H660Zm0-270v-150h150v150H660Zm0-270v-150h150v150H660Zm-270 0v-150h150v150H390Z"/>
            </svg>
          </button>
          <button id="profile-nav-btn" title="Profile">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
              <path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"/>
            </svg>
          </button>
          <button id="logout-btn" title="Logout">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
              <path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v120H200v560h280v120H200Zm440-160-55-58 102-102H360v-120h327L585-662l55-58 200 200-200 200Z"/>
            </svg>
          </button>
        </div>
      </header>
      <div class="content-area">
        <h2 class="text-center p-1">Upcoming Games</h2>
        <div id="game-list-loader" class="loader hidden"></div>
        <ul id="game-list"></ul>
        <p id="no-games-message" class="text-center mt-2 hidden">No games found. Why not create one?</p>
      </div>
      <button id="create-game-fab" title="Create Game">+</button>
    </div>

    <!-- Game Detail / Lobby Screen -->
    <div id="game-detail-screen" class="screen flex-col">
      <header class="app-header">
        <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
        <div class="logo">Game Lobby</div>
        <div></div>
      </header>
      <div class="content-area">
        <div id="game-detail-loader" class="loader"></div>
        <div id="game-detail-content" class="hidden">
          <div id="game-detail-header">
            <h2 id="game-detail-location">Location Name</h2>
            <div id="game-detail-meta" class="mb-1">
              <span id="game-detail-datetime">üìÖ Time</span>
              <span id="game-detail-creator">üëë Created by User</span>
            </div>
            <div id="game-detail-status" class="mb-1 bold">Status: <span class="status-indicator">Pending</span></div>
          </div>
          <hr>
          <h3>Players (<span id="player-count">0</span>/<span id="max-players">10</span>)</h3>
          <ul id="player-list" class="mb-1"></ul>
          <div id="game-actions">
            <button id="join-leave-game-btn" class="btn-primary w-full">Join Game</button>
            <button id="begin-game-btn" class="btn-secondary hidden">Begin Game (Creator Only)</button>
            <button id="cancel-game-btn" class="btn-danger hidden">Cancel Game (Creator Only)</button>
            <button id="share-game-btn" class="btn-accent mt-1">Share Game</button>
          </div>
          <div id="game-detail-error" class="error-text mt-1 text-center"></div>
          <hr>
          <button id="toggle-chat-btn" class="btn-outline w-full mt-1" style="max-width: 200px; margin-left: auto; margin-right:auto;">Show Chat</button>
        </div>
      </div>
    </div>

    <!-- Active Game Screen -->
    <div id="active-game-screen" class="screen flex-col">
      <header class="app-header">
        <div class="logo" style="font-size: 1.2rem;">Active Game</div>
        <button id="active-game-toggle-chat-btn" class="btn-outline" style="padding: 5px 10px; font-size: 0.9rem;">Chat</button>
      </header>
      <div class="content-area">
        <div id="active-game-loader" class="loader"></div>
        <div id="active-game-content" class="hidden">
          <div class="scoreboard">
            <div class="team-score">
              <div class="team-name">Team A</div>
              <div id="team-a-score" class="score" data-team="A">0</div>
            </div>
            <div class="vs">VS</div>
            <div class="team-score">
              <div class="team-name">Team B</div>
              <div id="team-b-score" class="score" data-team="B">0</div>
            </div>
          </div>
          <p id="score-proposal-message" class="text-center mb-1 success-text hidden"></p>
          <p id="score-error-message" class="text-center mb-1 error-text hidden"></p>
          <div class="team-display">
            <div id="team-a-list" class="team-column">
              <h4>Team A</h4>
            </div>
            <div id="team-b-list" class="team-column">
              <h4>Team B</h4>
            </div>
          </div>
          <p class="text-center mt-2" style="font-size: 0.9em; color: #aaa;">Click score to propose +1 point.</p>
        </div>
      </div>
      <div id="score-confirmation-modal" class="">
        <p id="score-confirm-text">Confirm +1 for Team X?</p>
        <button id="confirm-score-btn" class="btn-success">Confirm</button>
        <button id="reject-score-btn" class="btn-danger">Reject</button>
      </div>
    </div>

    <!-- Game End Screen -->
    <div id="game-end-screen" class="screen flex-col">
      <div id="confetti-container"></div>
      <div id="game-end-summary">
        <h2 id="game-end-title">Game Over!</h2>
        <p id="final-score" class="bold">Team A: 10 - Team B: 8</p>
        <div id="mvp-highlight">
          <h3>üèÜ Top Scorer (MVP) üèÜ</h3>
          <p id="mvp-username" class="bold">MVP_User</p>
          <p id="mvp-score">Scored X points</p>
        </div>
        <div id="game-end-actions" class="flex-col gap-05">
          <button id="back-to-main-btn" class="btn-primary">Back to Games</button>
          <button id="view-leaderboard-btn" class="btn-secondary">View Leaderboard</button>
          <button id="share-results-btn" class="btn-accent">Share Results</button>
        </div>
      </div>
    </div>

    <!-- Profile Screen -->
    <div id="profile-screen" class="screen flex-col">
      <header class="app-header">
        <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
        <div class="logo">Your Profile</div>
        <div></div>
      </header>
      <div class="content-area">
        <div id="profile-loader" class="loader"></div>
        <div id="profile-content" class="hidden">
          <div id="profile-header">
            <div id="profile-avatar">U</div>
            <div>
              <span id="profile-username" class="bold">Username</span>
              <button id="edit-profile-btn">‚úèÔ∏è</button>
              <button id="save-profile-btn" class="hidden">üíæ</button>
            </div>
            <input type="text" id="edit-profile-username-input" placeholder="New username">
            <div id="profile-email" style="font-size: 0.9em; color: #aaa;">user@example.com</div>
            <div id="profile-update-message" class="success-text mt-1"></div>
            <div id="profile-update-error" class="error-text mt-1"></div>
          </div>
          <div id="profile-stats">
            <div class="stat-item">
              <div id="profile-stat-points" class="stat-value">0</div>
              <div class="stat-label">Total Points</div>
            </div>
            <div class="stat-item">
              <div id="profile-stat-games" class="stat-value">0</div>
              <div class="stat-label">Games Played</div>
            </div>
            <div class="stat-item">
              <div id="profile-stat-mvp" class="stat-value">0</div>
              <div class="stat-label">MVP Awards</div>
            </div>
          </div>
          <hr style="max-width: 700px; margin-left: auto; margin-right: auto;">
          <h3 class="text-center">Game History</h3>
          <div id="game-history-loader" class="loader hidden"></div>
          <ul id="game-history-list"></ul>
          <p id="no-history-message" class="text-center mt-1 hidden">No completed games yet.</p>
        </div>
      </div>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboard-screen" class="screen flex-col">
      <header class="app-header">
        <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
        <div class="logo">Global Leaderboard</div>
        <div></div>
      </header>
      <div id="leaderboard-filter">
        <select id="location-filter">
          <option value="global" selected>Global Leaderboard</option>
          <option value="city">City Leaderboard</option>
          <option value="state">State Leaderboard</option>
          <option value="country">Country Leaderboard</option>
        </select>
      </div>
      <div class="content-area" style="padding: 0;">
        <h2 class="p-1 text-center" style="color: var(--primary-color);">Top Players (By Points)</h2>
        <div id="leaderboard-loader" class="loader"></div>
        <ul id="leaderboard-list"></ul>
        <p id="no-leaderboard-message" class="text-center mt-2 hidden">Leaderboard is empty.</p>
      </div>
    </div>

    <!-- Chat Drawer -->
    <div id="chat-drawer">
      <div id="chat-header">
        <h3>Game Chat</h3>
        <button id="close-chat-btn">&times;</button>
      </div>
      <div id="chat-messages"></div>
      <div id="chat-input-area">
        <input type="text" id="chat-input" placeholder="Type your message...">
        <button id="send-chat-btn" class="btn-secondary">Send</button>
      </div>
    </div>

    <!-- Create Game Modal -->
    <div id="create-game-modal" class="modal">
      <div id="create-game-form-container" class="modal-content">
        <button class="modal-close-btn" onclick="toggleCreateGameModal(false)">&times;</button>
        <h2>Create New Game</h2>
        <form id="create-game-form">
          <div class="mb-1">
            <label for="game-location">Location Name</label>
            <input type="text" id="game-location" required>
          </div>
          <div class="mb-1">
            <label for="game-datetime">Date & Time</label>
            <input type="datetime-local" id="game-datetime" required>
          </div>
          <div id="create-game-error" class="error-text mb-1"></div>
          <button type="submit" class="btn-primary w-full">Create Game</button>
        </form>
      </div>
    </div>

    <!-- Share Modal -->
    <div id="share-modal" class="modal">
      <div class="modal-content">
        <button class="modal-close-btn" onclick="toggleShareModal(false)">&times;</button>
        <h2>Share Game</h2>
        <div id="share-options">
          <p class="mb-1">Share this game link:</p>
          <input type="text" id="share-link-input" readonly>
          <button id="copy-share-link-btn" class="mt-1">Copy Link</button>
          <button id="web-share-api-btn" class="hidden">Share via...</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- SUPABASE CLIENT SETUP ---
    const SUPABASE_URL = 'https://aghnqhwhpiwndronbgkd.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFnaG5xaHdocGl3bmRyb25iZ2tkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5MDM4NTMsImV4cCI6MjA1OTQ3OTg1M30.jwYaXa_nb5HXQHjA3Bt6NUxYwQPDTawzNJvkOtI4Y1Q';
    let supabase = null;
    if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log("Supabase client initialized successfully.");
      } catch (error) {
        console.error("Error initializing Supabase client:", error);
        alert("Error initializing database connection. Please check console.");
        supabase = null;
      }
    } else {
      console.error("Supabase URL or Anon Key is not configured.");
      alert("App configuration error: Supabase URL/Key missing. Please contact support.");
    }

    // --- APPLICATION STATE ---
    let currentUser = null;
    let userProfile = null;
    let currentScreen = 'loading';
    let currentGameId = null;
    let currentGameData = null;
    let gameSubscription = null;
    let gamesSubscription = null;
    let scoreProposals = {};
    let currentScoreProposal = null;
    let confirmingScore = false;

    // Global location variables (to be set via Geolocation API)
    let userCity = null, userState = null, userCountry = null;

    // --- UI ELEMENTS CACHE ---
    const screens = {
      loading: document.getElementById('loading-screen'),
      auth: document.getElementById('auth-screen'),
      main: document.getElementById('main-app-screen'),
      detail: document.getElementById('game-detail-screen'),
      active: document.getElementById('active-game-screen'),
      end: document.getElementById('game-end-screen'),
      profile: document.getElementById('profile-screen'),
      leaderboard: document.getElementById('leaderboard-screen'),
    };
    const authForm = document.getElementById('auth-form');
    const authTitle = document.getElementById('auth-title');
    const authSubmitBtn = document.getElementById('auth-submit-btn');
    const authToggleBtn = document.getElementById('auth-toggle-btn');
    const authToggleText = document.getElementById('auth-toggle-text');
    const usernameField = document.getElementById('username-field');
    const usernameInput = document.getElementById('username');
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const authError = document.getElementById('auth-error');
    const logoutBtn = document.getElementById('logout-btn');
    const gameList = document.getElementById('game-list');
    const gameListLoader = document.getElementById('game-list-loader');
    const noGamesMessage = document.getElementById('no-games-message');
    const createGameFab = document.getElementById('create-game-fab');
    const createGameModal = document.getElementById('create-game-modal');
    const createGameForm = document.getElementById('create-game-form');
    const createGameError = document.getElementById('create-game-error');
    const gameDetailLoader = document.getElementById('game-detail-loader');
    const gameDetailContent = document.getElementById('game-detail-content');
    const gameDetailLocation = document.getElementById('game-detail-location');
    const gameDetailDatetime = document.getElementById('game-detail-datetime');
    const gameDetailCreator = document.getElementById('game-detail-creator');
    const gameDetailStatus = document.getElementById('game-detail-status').querySelector('.status-indicator');
    const playerCount = document.getElementById('player-count');
    const maxPlayers = document.getElementById('max-players');
    const playerList = document.getElementById('player-list');
    const joinLeaveGameBtn = document.getElementById('join-leave-game-btn');
    const beginGameBtn = document.getElementById('begin-game-btn');
    const cancelGameBtn = document.getElementById('cancel-game-btn');
    const shareGameBtn = document.getElementById('share-game-btn');
    const gameDetailError = document.getElementById('game-detail-error');
    const activeGameLoader = document.getElementById('active-game-loader');
    const activeGameContent = document.getElementById('active-game-content');
    const teamAScore = document.getElementById('team-a-score');
    const teamBScore = document.getElementById('team-b-score');
    const teamAList = document.getElementById('team-a-list');
    const teamBList = document.getElementById('team-b-list');
    const scoreProposalMessage = document.getElementById('score-proposal-message');
    const scoreErrorMessage = document.getElementById('score-error-message');
    const scoreConfirmationModal = document.getElementById('score-confirmation-modal');
    const scoreConfirmText = document.getElementById('score-confirm-text');
    const confirmScoreBtn = document.getElementById('confirm-score-btn');
    const rejectScoreBtn = document.getElementById('reject-score-btn');
    const gameEndScreen = document.getElementById('game-end-screen');
    const gameEndTitle = document.getElementById('game-end-title');
    const finalScore = document.getElementById('final-score');
    const mvpUsername = document.getElementById('mvp-username');
    const mvpScore = document.getElementById('mvp-score');
    const confettiContainer = document.getElementById('confetti-container');
    const backToMainBtn = document.getElementById('back-to-main-btn');
    const viewLeaderboardBtn = document.getElementById('view-leaderboard-btn');
    const shareResultsBtn = document.getElementById('share-results-btn');
    const profileLoader = document.getElementById('profile-loader');
    const profileContent = document.getElementById('profile-content');
    const profileAvatar = document.getElementById('profile-avatar');
    const profileUsername = document.getElementById('profile-username');
    const profileEmail = document.getElementById('profile-email');
    const editProfileBtn = document.getElementById('edit-profile-btn');
    const saveProfileBtn = document.getElementById('save-profile-btn');
    const editProfileUsernameInput = document.getElementById('edit-profile-username-input');
    const profileUpdateMessage = document.getElementById('profile-update-message');
    const profileUpdateError = document.getElementById('profile-update-error');
    const profileStatPoints = document.getElementById('profile-stat-points');
    const profileStatGames = document.getElementById('profile-stat-games');
    const profileStatMvp = document.getElementById('profile-stat-mvp');
    const gameHistoryLoader = document.getElementById('game-history-loader');
    const gameHistoryList = document.getElementById('game-history-list');
    const noHistoryMessage = document.getElementById('no-history-message');
    const leaderboardLoader = document.getElementById('leaderboard-loader');
    const leaderboardList = document.getElementById('leaderboard-list');
    const noLeaderboardMessage = document.getElementById('no-leaderboard-message');
    const profileNavBtn = document.getElementById('profile-nav-btn');
    const leaderboardNavBtn = document.getElementById('leaderboard-nav-btn');
    const backBtns = document.querySelectorAll('.back-btn');
    const chatDrawer = document.getElementById('chat-drawer');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat-btn');
    const closeChatBtn = document.getElementById('close-chat-btn');
    const toggleChatBtn = document.getElementById('toggle-chat-btn');
    const activeGameToggleChatBtn = document.getElementById('active-game-toggle-chat-btn');
    const shareModal = document.getElementById('share-modal');
    const shareLinkInput = document.getElementById('share-link-input');
    const copyShareLinkBtn = document.getElementById('copy-share-link-btn');
    const webShareApiBtn = document.getElementById('web-share-api-btn');
    const locationFilter = document.getElementById('location-filter');

    // --- UTILITY FUNCTIONS ---
    const debounce = (func, delay) => {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
        }, delay);
      };
    };

    const formatDate = (dateString) => {
      if (!dateString) return 'Date TBD';
      try {
        const date = new Date(dateString);
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(now.getDate() + 1);
        const optionsTime = { hour: 'numeric', minute: 'numeric', hour12: true };
        const optionsDate = { month: 'short', day: 'numeric' };
        if (date.toDateString() === now.toDateString()) {
          return `Today, ${date.toLocaleTimeString('en-US', optionsTime)}`;
        } else if (date.toDateString() === tomorrow.toDateString()) {
          return `Tomorrow, ${date.toLocaleTimeString('en-US', optionsTime)}`;
        } else {
          return `${date.toLocaleDateString('en-US', optionsDate)}, ${date.toLocaleTimeString('en-US', optionsTime)}`;
        }
      } catch (e) {
        console.error("Error formatting date:", dateString, e);
        return "Invalid Date";
      }
    };

    const showElement = (el) => el?.classList.remove('hidden');
    const hideElement = (el) => el?.classList.add('hidden');
    const enableElement = (el) => { if(el) el.disabled = false; };
    const disableElement = (el) => { if(el) el.disabled = true; };

    // --- New: Get User Location via Geolocation API and Reverse Geocoding ---
    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(async (position) => {
          const { latitude, longitude } = position.coords;
          console.log("User coordinates:", latitude, longitude);
          try {
            // Use a free reverse geocoding API (Nominatim) to get city/state/country
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`);
            const data = await response.json();
            userCity = data.address.city || data.address.town || data.address.village || "Unknown City";
            userState = data.address.state || "Unknown State";
            userCountry = data.address.country || "Unknown Country";
            console.log("User location:", userCity, userState, userCountry);
            // Optionally update UI or refetch leaderboard if already on leaderboard screen
          } catch (error) {
            console.error("Error reverse geocoding location:", error);
            // Fallback dummy location for demo purposes
            userCity = "New York";
            userState = "NY";
            userCountry = "USA";
          }
        }, (error) => {
          console.error("Geolocation error:", error);
          // Fallback dummy location for demo purposes
          userCity = "New York";
          userState = "NY";
          userCountry = "USA";
        });
      } else {
        console.error("Geolocation not supported by browser.");
        userCity = "New York";
        userState = "NY";
        userCountry = "USA";
      }
    }
    // Get user location on load
    getUserLocation();

    // --- SCREEN RENDERING FUNCTIONS ---
    const renderGameList = (games) => {
      gameList.innerHTML = '';
      hideElement(gameListLoader);
      if (!games || games.length === 0) {
        showElement(noGamesMessage);
        return;
      }
      hideElement(noGamesMessage);
      games.sort((a, b) => {
        if (a.status === 'pending' && b.status !== 'pending') return -1;
        if (a.status !== 'pending' && b.status === 'pending') return 1;
        const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
        const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
        return timeA - timeB;
      });
      games.forEach(game => {
        const li = document.createElement('li');
        li.classList.add('game-list-item');
        li.dataset.gameId = game.id;
        const players = game.players || [];
        const playerCount = players.length;
        const maxP = 10;
        li.innerHTML = `
          <div class="game-info">
            <h3>${game.location_name || 'Unnamed Game'}</h3>
            <div class="game-meta">
              <span>üìç ${game.location_name || 'TBD'}</span> | <span>üìÖ ${formatDate(game.start_time)}</span>
            </div>
          </div>
          <div class="game-status-indicator status-${game.status || 'unknown'}">
            ${game.status === 'pending' ? `${playerCount}/${maxP} Players` : game.status.charAt(0).toUpperCase() + game.status.slice(1)}
          </div>
        `;
        li.addEventListener('click', () => handleGameItemClick(game.id));
        gameList.appendChild(li);
      });
      requestAnimationFrame(() => {
        document.querySelectorAll('.game-list-item').forEach((item, index) => {
          item.style.animationDelay = `${index * 0.05}s`;
          item.style.opacity = '1';
          item.style.transform = 'translateY(0)';
        });
      });
    };

    const renderGameDetail = (game) => {
      hideElement(gameDetailLoader);
      if (!game) {
        gameDetailError.textContent = "Could not load game details.";
        showElement(gameDetailError);
        hideElement(gameDetailContent);
        return;
      }
      showElement(gameDetailContent);
      hideElement(gameDetailError);
      currentGameData = game;
      gameDetailLocation.textContent = game.location_name || 'Unnamed Game';
      gameDetailDatetime.textContent = `üìÖ ${formatDate(game.start_time)}`;
      gameDetailCreator.textContent = `üëë Creator ID: ${game.creator_id.substring(0, 8)}...`;
      fetchUserProfileAndSetCreator(game.creator_id);
      const statusClass = `status-${game.status || 'unknown'}`;
      gameDetailStatus.className = `status-indicator ${statusClass}`;
      gameDetailStatus.textContent = game.status ? game.status.charAt(0).toUpperCase() + game.status.slice(1) : 'Unknown';
      const players = game.players || [];
      playerCount.textContent = players.length;
      playerList.innerHTML = '';
      players.forEach(player => {
        const li = document.createElement('li');
        li.classList.add('player-list-item');
        li.innerHTML = `
          <div class="player-avatar">${getUserAvatarText(player.username)}</div>
          <span class="player-username">${player.username || 'Guest'}</span>
          <span class="player-status">${player.user_id === game.creator_id ? 'Creator' : ''}</span>
        `;
        playerList.appendChild(li);
      });
      updateGameDetailButtons(game);
    };

    const fetchUserProfileAndSetCreator = async (creatorId) => {
      const profile = await getUserProfile(creatorId);
      if (profile && profile.username) {
        gameDetailCreator.textContent = `üëë Created by ${profile.username}`;
      } else {
        gameDetailCreator.textContent = `üëë Creator ID: ${creatorId.substring(0, 8)}...`;
      }
    };

    const updateGameDetailButtons = (game) => {
      if (!currentUser || !game) return;
      const isCreator = game.creator_id === currentUser.id;
      const players = game.players || [];
      const isPlayer = players.some(p => p.user_id === currentUser.id);
      const canJoin = players.length < 10 && !isPlayer && game.status === 'pending';
      const canLeave = isPlayer && game.status === 'pending' && !isCreator;
      const canBegin = isCreator && game.status === 'pending' && players.length >= 2;
      const canCancel = isCreator && game.status === 'pending';
      if (canJoin) {
        joinLeaveGameBtn.textContent = 'Join Game';
        joinLeaveGameBtn.className = 'btn-primary w-full';
        showElement(joinLeaveGameBtn);
        enableElement(joinLeaveGameBtn);
      } else if (canLeave) {
        joinLeaveGameBtn.textContent = 'Leave Game';
        joinLeaveGameBtn.className = 'btn-danger w-full';
        showElement(joinLeaveGameBtn);
        enableElement(joinLeaveGameBtn);
      } else {
        hideElement(joinLeaveGameBtn);
      }
      if (canBegin) {
        showElement(beginGameBtn);
        enableElement(beginGameBtn);
      } else {
        hideElement(beginGameBtn);
      }
      if (canCancel) {
        showElement(cancelGameBtn);
        enableElement(cancelGameBtn);
      } else {
        hideElement(cancelGameBtn);
      }
      if (game.status === 'pending' || game.status === 'active') {
        showElement(shareGameBtn);
      } else {
        hideElement(shareGameBtn);
      }
    };

    const renderActiveGame = (game) => {
      hideElement(activeGameLoader);
      if (!game || game.status !== 'active') {
        console.warn("Attempted to render active game, but status is not 'active'.", game?.status);
        return;
      }
      showElement(activeGameContent);
      currentGameData = game;
      teamAScore.textContent = game.score_a || 0;
      teamBScore.textContent = game.score_b || 0;
      const renderTeam = (teamListEl, teamData, teamName) => {
        teamListEl.innerHTML = `<h4>${teamName}</h4>`;
        const players = teamData || [];
        if (players.length === 0) {
          teamListEl.innerHTML += `<p style="font-size: 0.8em; color: #888; text-align: center;">No players assigned.</p>`;
        } else {
          players.forEach(player => {
            const div = document.createElement('div');
            div.classList.add('team-player');
            div.textContent = player.username || `User ${player.user_id.substring(0,6)}`;
            teamListEl.appendChild(div);
          });
        }
      };
      renderTeam(teamAList, game.team_a, 'Team A');
      renderTeam(teamBList, game.team_b, 'Team B');
      updateScoreProposalUI(game.point_proposals);
      // Check for game end condition handled via score update subscription
    };

    const renderGameEnd = (game) => {
      if (!game) {
        console.error("No game data provided for end screen");
        backToMainBtn.onclick = () => navigateTo('main');
        return;
      }
      hideElement(activeGameLoader);
      showElement(gameEndScreen);
      const scoreA = game.score_a || 0;
      const scoreB = game.score_b || 0;
      const winner = scoreA > scoreB ? 'A' : (scoreB > scoreA ? 'B' : 'draw');
      if (winner === 'A') {
        gameEndTitle.textContent = 'Team A Wins!';
        gameEndScreen.style.background = 'linear-gradient(180deg, var(--primary-color) 0%, #8A2BE2 100%)';
      } else if (winner === 'B') {
        gameEndTitle.textContent = 'Team B Wins!';
        gameEndScreen.style.background = 'linear-gradient(180deg, var(--accent-color) 0%, var(--secondary-color) 100%)';
      } else {
        gameEndTitle.textContent = 'It\'s a Draw!';
        gameEndScreen.style.background = 'linear-gradient(180deg, var(--surface-color) 0%, var(--background-color) 100%)';
      }
      finalScore.textContent = `Final Score: ${scoreA} - ${scoreB}`;
      if (game.mvp_user_id) {
        const allPlayers = [...(game.team_a || []), ...(game.team_b || [])];
        const mvp = allPlayers.find(p => p.user_id === game.mvp_user_id);
        if (mvp) {
          mvpUsername.textContent = mvp.username || 'Unknown MVP';
          mvpScore.textContent = `(Stats unavailable in demo)`;
          showElement(document.getElementById('mvp-highlight'));
        } else {
          hideElement(document.getElementById('mvp-highlight'));
        }
      } else {
        hideElement(document.getElementById('mvp-highlight'));
      }
      startConfetti();
      backToMainBtn.onclick = () => {
        stopConfetti();
        navigateTo('main');
        fetchGames();
      };
      viewLeaderboardBtn.onclick = () => {
        stopConfetti();
        navigateTo('leaderboard');
        fetchLeaderboard();
      };
      shareResultsBtn.onclick = () => {
        const shareText = `Game Finished! ${game.location_name || 'Game'}: Team A (${scoreA}) vs Team B (${scoreB}). ${winner ? `Team ${winner} wins!` : 'Draw!'}`;
        showShareModal(shareText, window.location.href);
      };
    };

    const renderProfile = (profileData) => {
      hideElement(profileLoader);
      if (!profileData) {
        profileContent.innerHTML = `<p class="error-text p-2 text-center">Could not load profile. Please try again later.</p>`;
        showElement(profileContent);
        return;
      }
      showElement(profileContent);
      userProfile = profileData;
      profileUsername.textContent = profileData.username || 'No Username Set';
      profileEmail.textContent = currentUser?.email || 'No email associated';
      profileAvatar.textContent = getUserAvatarText(profileData.username);
      editProfileUsernameInput.value = profileData.username || '';
      profileStatPoints.textContent = profileData.total_points_scored || 0;
      profileStatGames.textContent = profileData.games_played || 0;
      profileStatMvp.textContent = profileData.mvp_awards || 0;
      loadGameHistory(profileData.user_id);
    };

    const renderGameHistory = (games) => {
      hideElement(gameHistoryLoader);
      gameHistoryList.innerHTML = '';
      if (!games || games.length === 0) {
        showElement(noHistoryMessage);
        return;
      }
      hideElement(noHistoryMessage);
      games.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
      games.forEach(game => {
        const li = document.createElement('li');
        li.classList.add('history-item');
        const isPlayerA = game.team_a?.some(p => p.user_id === currentUser.id);
        const isPlayerB = game.team_b?.some(p => p.user_id === currentUser.id);
        let result = 'N/A';
        let resultClass = '';
        if (game.winner === 'A' && isPlayerA) { result = 'Win'; resultClass = 'result-win'; }
        else if (game.winner === 'B' && isPlayerB) { result = 'Win'; resultClass = 'result-win'; }
        else if (game.winner === 'A' && isPlayerB) { result = 'Loss'; resultClass = 'result-loss'; }
        else if (game.winner === 'B' && isPlayerA) { result = 'Loss'; resultClass = 'result-loss'; }
        else if (!game.winner || game.winner === 'draw') { result = 'Draw'; }
        const isMvp = game.mvp_user_id === currentUser.id;
        li.innerHTML = `
          <div class="history-details">${game.location_name || 'Game'} - ${formatDate(game.created_at)}</div>
          <div class="history-score">Score: ${game.score_a || 0} - ${game.score_b || 0}</div>
          <div class="history-result ${resultClass}">Result: ${result} ${isMvp ? '(üèÜ MVP)' : ''}</div>
        `;
        gameHistoryList.appendChild(li);
      });
    };

    const renderLeaderboard = (players) => {
      hideElement(leaderboardLoader);
      leaderboardList.innerHTML = '';
      if (!players || players.length === 0) {
        showElement(noLeaderboardMessage);
        return;
      }
      hideElement(noLeaderboardMessage);
      players.sort((a, b) => (b.total_points_scored || 0) - (a.total_points_scored || 0));
      players.forEach((player, index) => {
        const li = document.createElement('li');
        li.classList.add('leaderboard-item');
        li.style.animationDelay = `${index * 0.05}s`;
        li.innerHTML = `
          <span class="leaderboard-rank">${index + 1}</span>
          <div class="leaderboard-avatar">${getUserAvatarText(player.username)}</div>
          <div class="leaderboard-info">
            <div class="leaderboard-username">${player.username || 'Anonymous Player'}</div>
            <div class="leaderboard-stat">üèÜ ${player.mvp_awards || 0} MVPs | ${player.games_played || 0} Games</div>
          </div>
          <div class="leaderboard-score">${player.total_points_scored || 0} PTS</div>
        `;
        leaderboardList.appendChild(li);
      });
      requestAnimationFrame(() => {
        document.querySelectorAll('.leaderboard-item').forEach(item => {
          item.style.opacity = '1';
          item.style.transform = 'translateY(0)';
        });
      });
    };

    const renderChatMessages = (messages) => {
      if (!messages || !Array.isArray(messages)) {
        console.warn("Invalid chat messages format:", messages);
        messages = [];
      }
      const shouldScroll = chatMessages.scrollTop + chatMessages.clientHeight >= chatMessages.scrollHeight - 50;
      chatMessages.innerHTML = '';
      messages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message');
        const isOwnMessage = msg.user_id === currentUser?.id;
        if (isOwnMessage) {
          messageDiv.classList.add('own');
        }
        messageDiv.innerHTML = `
          <div class="message-bubble">${msg.message || ''}</div>
          <div class="message-meta">
            ${!isOwnMessage ? `<span class="message-sender">${msg.username || 'User'}</span>` : ''}
            <span>${formatDate(msg.timestamp || new Date())}</span>
          </div>
        `;
        chatMessages.appendChild(messageDiv);
      });
      if (shouldScroll || chatDrawer.classList.contains('open')) {
        scrollToChatBottom();
      }
    };

    // --- DATA FETCHING AND UPDATING ---
    const fetchGames = async () => {
      if (!supabase) return;
      showElement(gameListLoader);
      hideElement(noGamesMessage);
      gameList.innerHTML = '';
      try {
        const { data, error } = await supabase
          .from('games')
          .select('*')
          .in('status', ['pending', 'active'])
          .order('start_time', { ascending: true, nullsLast: true });
        if (error) throw error;
        renderGameList(data);
        subscribeToGamesList();
      } catch (error) {
        console.error('Error fetching games:', error);
        hideElement(gameListLoader);
        showElement(noGamesMessage);
        noGamesMessage.textContent = "Could not load games. Try again later.";
      }
    };

    const fetchGameDetails = async (gameId) => {
      if (!supabase || !gameId) return;
      showElement(gameDetailLoader);
      hideElement(gameDetailContent);
      hideElement(gameDetailError);
      try {
        const { data, error } = await supabase
          .from('games')
          .select('*')
          .eq('id', gameId)
          .single();
        if (error) throw error;
        if (!data) throw new Error("Game not found.");
        renderGameDetail(data);
        subscribeToGame(gameId);
        renderChatMessages(data.chat_log || []);
      } catch (error) {
        console.error('Error fetching game details:', error);
        hideElement(gameDetailLoader);
        showElement(gameDetailError);
        gameDetailError.textContent = `Could not load game details: ${error.message}. It might have been cancelled.`;
        hideElement(gameDetailContent);
      }
    };

    const createGame = async (location, dateTime) => {
      if (!supabase || !currentUser) return { error: { message: 'Not logged in or Supabase unavailable.' }};
      try {
        if (!location.trim() || !dateTime) {
          return { error: { message: 'Location and Date/Time are required.' } };
        }
        if (!userProfile || !userProfile.username) {
          userProfile = await getUserProfile(currentUser.id);
          if (!userProfile || !userProfile.username) {
            return { error: { message: 'Please set your username in your profile before creating games.' } };
          }
        }
        const initialPlayer = { user_id: currentUser.id, username: userProfile.username };
        const { data, error } = await supabase
          .from('games')
          .insert({
            creator_id: currentUser.id,
            location_name: location,
            start_time: dateTime,
            status: 'pending',
            players: [initialPlayer],
            chat_log: [{
              user_id: 'system',
              username: 'System',
              message: `${userProfile.username} created the game!`,
              timestamp: new Date().toISOString()
            }]
          })
          .select()
          .single();
        return { data, error };
      } catch (error) {
        console.error('Error creating game:', error);
        return { error };
      }
    };

    const joinGame = async (gameId) => {
      if (!supabase || !currentUser || !currentGameData) return;
      disableElement(joinLeaveGameBtn);
      gameDetailError.textContent = '';
      try {
        const currentProfile = await getUserProfile(currentUser.id);
        if (!currentProfile || !currentProfile.username) {
          throw new Error('Please set your username in your profile first.');
        }
        const players = currentGameData.players || [];
        if (players.length >= 10) {
          throw new Error('Game is full!');
        }
        if (players.some(p => p.user_id === currentUser.id)) {
          enableElement(joinLeaveGameBtn);
          return;
        }
        const newPlayer = { user_id: currentUser.id, username: currentProfile.username };
        const updatedPlayers = [...players, newPlayer];
        const joinMessage = {
          user_id: 'system',
          username: 'System',
          message: `${currentProfile.username} joined the game!`,
          timestamp: new Date().toISOString()
        };
        const updatedChatLog = [...(currentGameData.chat_log || []), joinMessage];
        const { error } = await supabase
          .from('games')
          .update({ players: updatedPlayers, chat_log: updatedChatLog })
          .eq('id', gameId);
        if (error) throw error;
      } catch (error) {
        console.error('Error joining game:', error);
        gameDetailError.textContent = `Error joining game: ${error.message}`;
        showElement(gameDetailError);
        enableElement(joinLeaveGameBtn);
      }
    };

    const leaveGame = async (gameId) => {
      if (!supabase || !currentUser || !currentGameData) return;
      disableElement(joinLeaveGameBtn);
      gameDetailError.textContent = '';
      try {
        let players = currentGameData.players || [];
        if (!players.some(p => p.user_id === currentUser.id)) {
          enableElement(joinLeaveGameBtn);
          return;
        }
        if (currentGameData.creator_id === currentUser.id) {
          throw new Error('Creator cannot leave, please cancel the game instead.');
        }
        const updatedPlayers = players.filter(p => p.user_id !== currentUser.id);
        const currentProfile = await getUserProfile(currentUser.id);
        const username = currentProfile?.username || 'A player';
        const leaveMessage = {
          user_id: 'system',
          username: 'System',
          message: `${username} left the game.`,
          timestamp: new Date().toISOString()
        };
        const updatedChatLog = [...(currentGameData.chat_log || []), leaveMessage];
        const { error } = await supabase
          .from('games')
          .update({ players: updatedPlayers, chat_log: updatedChatLog })
          .eq('id', gameId);
        if (error) throw error;
      } catch (error) {
        console.error('Error leaving game:', error);
        gameDetailError.textContent = `Error leaving game: ${error.message}`;
        showElement(gameDetailError);
      }
    };

    const cancelGame = async (gameId) => {
      if (!supabase || !currentUser || !currentGameData) return;
      gameDetailError.textContent = '';
      if (currentGameData.creator_id !== currentUser.id) {
        gameDetailError.textContent = "Only the creator can cancel the game.";
        showElement(gameDetailError);
        return;
      }
      disableElement(cancelGameBtn);
      disableElement(beginGameBtn);
      if (!confirm("Are you sure you want to cancel this game? This cannot be undone.")) {
        enableElement(cancelGameBtn);
        if (currentGameData?.players?.length >= 2) enableElement(beginGameBtn);
        return;
      }
      try {
        const { error } = await supabase
          .from('games')
          .update({ status: 'cancelled' })
          .eq('id', gameId);
        if (error) throw error;
      } catch (error) {
        console.error('Error cancelling game:', error);
        gameDetailError.textContent = `Error cancelling game: ${error.message}`;
        showElement(gameDetailError);
        enableElement(cancelGameBtn);
        if (currentGameData?.players?.length >= 2) enableElement(beginGameBtn);
      }
    };

    const beginGame = async (gameId) => {
      if (!supabase || !currentUser || !currentGameData) return;
      gameDetailError.textContent = '';
      if (currentGameData.creator_id !== currentUser.id) {
        gameDetailError.textContent = "Only the creator can begin the game.";
        showElement(gameDetailError);
        return;
      }
      if ((currentGameData.players?.length || 0) < 2) {
        gameDetailError.textContent = "Need at least 2 players to start.";
        showElement(gameDetailError);
        return;
      }
      disableElement(beginGameBtn);
      disableElement(cancelGameBtn);
      disableElement(joinLeaveGameBtn);
      try {
        let players = [...(currentGameData.players || [])];
        for (let i = players.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [players[i], players[j]] = [players[j], players[i]];
        }
        const midPoint = Math.ceil(players.length / 2);
        const teamA = players.slice(0, midPoint);
        const teamB = players.slice(midPoint);
        const startMessage = {
          user_id: 'system',
          username: 'System',
          message: `The game has started! Good luck!`,
          timestamp: new Date().toISOString()
        };
        const updatedChatLog = [...(currentGameData.chat_log || []), startMessage];
        const { error } = await supabase
          .from('games')
          .update({
            status: 'active',
            team_a: teamA,
            team_b: teamB,
            score_a: 0,
            score_b: 0,
            point_proposals: null,
            players: null,
            chat_log: updatedChatLog
          })
          .eq('id', gameId);
        if (error) throw error;
      } catch (error) {
        console.error('Error beginning game:', error);
        gameDetailError.textContent = `Error starting game: ${error.message}`;
        showElement(gameDetailError);
        enableElement(beginGameBtn);
        enableElement(cancelGameBtn);
        updateGameDetailButtons(currentGameData);
      }
    };

    // --- Collaborative Scoring Logic ---
    const proposeScore = async (team) => {
      if (!supabase || !currentUser || !currentGameData || currentGameData.status !== 'active' || confirmingScore) return;
      const proposalKey = team === 'A' ? 'teamA' : 'teamB';
      const currentProposals = currentGameData.point_proposals || {};
      if (confirmingScore || (Object.keys(currentProposals).length > 0 && !currentProposals[proposalKey])) {
        setScoreErrorMessage("Wait for the current score proposal to resolve.");
        return;
      }
      if (currentProposals[proposalKey]?.proposedBy === currentUser.id) {
        setScoreErrorMessage("Waiting for others to confirm your proposal.");
        return;
      }
      if (currentProposals[proposalKey]?.confirmedBy?.includes(currentUser.id)) {
        setScoreErrorMessage("Waiting for others to confirm.");
        return;
      }
      console.log(`Proposing +1 for Team ${team}`);
      setScoreProposalMessage(`Proposing +1 for Team ${team}... Waiting for confirmation...`);
      hideElement(scoreErrorMessage);
      const newProposalData = {
        [proposalKey]: {
          proposedBy: currentUser.id,
          confirmedBy: [currentUser.id]
        }
      };
      try {
        const { error } = await supabase
          .from('games')
          .update({ point_proposals: newProposalData })
          .eq('id', currentGameId);
        if (error) throw error;
      } catch (error) {
        console.error("Error proposing score:", error);
        setScoreErrorMessage("Error submitting proposal.");
        hideElement(scoreProposalMessage);
      }
    };

    const confirmScoreProposal = async () => {
      if (!supabase || !currentUser || !currentGameData || !currentScoreProposal || confirmingScore) return;
      if (currentScoreProposal.proposedBy === currentUser.id && currentGameData.point_proposals[currentScoreProposal.team === 'A' ? 'teamA' : 'teamB']?.confirmedBy?.length <= 1) {
        console.log("Cannot confirm own initial proposal.");
        return;
      }
      confirmingScore = true;
      disableElement(confirmScoreBtn);
      disableElement(rejectScoreBtn);
      const proposalKey = currentScoreProposal.team === 'A' ? 'teamA' : 'teamB';
      let currentProposals = currentGameData.point_proposals || {};
      if (!currentProposals[proposalKey] || currentProposals[proposalKey].confirmedBy?.includes(currentUser.id)) {
        console.warn("Proposal not found or already confirmed by user.");
        resetScoreConfirmationUI();
        confirmingScore = false;
        return;
      }
      const updatedConfirmedBy = [...(currentProposals[proposalKey].confirmedBy || []), currentUser.id];
      const updatedProposal = {
        ...currentProposals[proposalKey],
        confirmedBy: updatedConfirmedBy
      };
      const newProposalData = {
        ...currentProposals,
        [proposalKey]: updatedProposal
      };
      try {
        const { error } = await supabase
          .from('games')
          .update({ point_proposals: newProposalData })
          .eq('id', currentGameId);
        if (error) throw error;
        resetScoreConfirmationUI();
      } catch (error) {
        console.error("Error confirming score:", error);
        setScoreErrorMessage("Failed to confirm score.");
        resetScoreConfirmationUI();
      } finally {
        setTimeout(() => { confirmingScore = false; }, 100);
      }
    };

    const rejectScoreProposal = async () => {
      if (!supabase || !currentUser || !currentGameData || !currentScoreProposal) return;
      console.log("Rejecting score proposal for team:", currentScoreProposal.team);
      const proposalKey = currentScoreProposal.team === 'A' ? 'teamA' : 'teamB';
      let currentProposals = currentGameData.point_proposals || {};
      if (currentProposals[proposalKey]) {
        delete currentProposals[proposalKey];
        try {
          const { error } = await supabase
            .from('games')
            .update({ point_proposals: Object.keys(currentProposals).length > 0 ? currentProposals : null })
            .eq('id', currentGameId);
          if (error) throw error;
        } catch(error) {
          console.error("Error rejecting score proposal in DB:", error);
          setScoreErrorMessage("Failed to reject proposal.");
        }
      }
      resetScoreConfirmationUI();
      setScoreProposalMessage("Score proposal rejected.");
      setTimeout(() => hideElement(scoreProposalMessage), 3000);
    };

    const checkAndApplyScore = async (gameData) => {
      if (!gameData || gameData.status !== 'active') return;
      const proposals = gameData.point_proposals;
      resetScoreConfirmationUI();
      if (!proposals || Object.keys(proposals).length === 0) {
        return;
      }
      const totalPlayers = (gameData.team_a?.length || 0) + (gameData.team_b?.length || 0);
      const requiredConfirmations = Math.floor(totalPlayers / 2) + 1;
      let scoreUpdated = false;
      let updatePayload = {};
      let appliedProposalKey = null;
      for (const key in proposals) {
        const proposal = proposals[key];
        if (proposal && proposal.confirmedBy && proposal.confirmedBy.length >= requiredConfirmations) {
          const team = key === 'teamA' ? 'A' : 'B';
          console.log(`Sufficient confirmations (${proposal.confirmedBy.length}/${requiredConfirmations}) for Team ${team}! Applying score.`);
          if (team === 'A') {
            updatePayload.score_a = (gameData.score_a || 0) + 1;
          } else {
            updatePayload.score_b = (gameData.score_b || 0) + 1;
          }
          updatePayload.point_proposals = null;
          scoreUpdated = true;
          appliedProposalKey = key;
          break;
        }
      }
      if (scoreUpdated) {
        hideElement(scoreProposalMessage);
        hideElement(scoreErrorMessage);
        try {
          const { data: updatedGame, error } = await supabase
            .from('games')
            .update(updatePayload)
            .eq('id', gameData.id)
            .select()
            .single();
          if (error) throw error;
          console.log("Score applied successfully.");
          currentGameData = updatedGame;
          const scoreLimit = 11;
          if ((updatedGame.score_a >= scoreLimit || updatedGame.score_b >= scoreLimit) && updatedGame.score_a !== updatedGame.score_b) {
            endGame(updatedGame);
          }
        } catch (error) {
          console.error("Error applying final score:", error);
          setScoreErrorMessage("Error applying score update.");
        }
      } else {
        updateScoreProposalUI(proposals);
      }
    };

    const updateScoreProposalUI = (proposals) => {
      resetScoreConfirmationUI();
      hideElement(scoreProposalMessage);
      hideElement(scoreErrorMessage);
      proposals = proposals || {};
      let activeProposal = null;
      let activeProposalKey = null;
      for (const key in proposals) {
        if (proposals[key]) {
          activeProposal = proposals[key];
          activeProposalKey = key;
          break;
        }
      }
      if (activeProposal) {
        const team = activeProposalKey === 'teamA' ? 'A' : 'B';
        const proposerId = activeProposal.proposedBy;
        const confirmedBy = activeProposal.confirmedBy || [];
        const totalPlayers = (currentGameData?.team_a?.length || 0) + (currentGameData?.team_b?.length || 0);
        const requiredConfirmations = Math.max(1, Math.floor(totalPlayers / 2) + 1);
        if (currentUser && !confirmedBy.includes(currentUser.id)) {
          currentScoreProposal = { proposedBy: proposerId, team: team };
          scoreConfirmText.textContent = `Confirm +1 Team ${team}? (${confirmedBy.length}/${requiredConfirmations} needed)`;
          showScoreConfirmationModal();
        } else if (currentUser && confirmedBy.includes(currentUser.id)) {
          setScoreProposalMessage(`Waiting for others... (${confirmedBy.length}/${requiredConfirmations} confirmed)`);
        } else {
          setScoreProposalMessage(`Score proposal active for Team ${team} (${confirmedBy.length}/${requiredConfirmations} confirmed)`);
        }
      }
    };

    const showScoreConfirmationModal = () => {
      scoreConfirmationModal.classList.add('visible');
      enableElement(confirmScoreBtn);
      enableElement(rejectScoreBtn);
    };

    const resetScoreConfirmationUI = () => {
      scoreConfirmationModal.classList.remove('visible');
      currentScoreProposal = null;
    };

    const setScoreProposalMessage = (message) => {
      scoreProposalMessage.textContent = message;
      showElement(scoreProposalMessage);
      hideElement(scoreErrorMessage);
    };

    const setScoreErrorMessage = (message) => {
      scoreErrorMessage.textContent = message;
      showElement(scoreErrorMessage);
      hideElement(scoreProposalMessage);
      setTimeout(() => hideElement(scoreErrorMessage), 5000);
    };

    const endGame = async (gameData) => {
      if (!supabase || !currentUser || gameData.status !== 'active') {
        console.warn("endGame called on non-active or null game", gameData?.status);
        return;
      }
      console.log("Ending game:", gameData.id);
      const scoreA = Number(gameData.score_a || 0);
      const scoreB = Number(gameData.score_b || 0);
      const winner = scoreA > scoreB ? 'A' : (scoreB > scoreA ? 'B' : 'draw');
      let mvpUserId = null;
      const winningTeam = winner === 'A' ? gameData.team_a : (winner === 'B' ? gameData.team_b : null);
      if (winningTeam && winningTeam.length > 0) {
        mvpUserId = winningTeam[0].user_id;
      }
      const updatePayload = {
        status: 'finished',
        winner: winner,
        mvp_user_id: mvpUserId,
        point_proposals: null
      };
      try {
        const { error: gameUpdateError } = await supabase
          .from('games')
          .update(updatePayload)
          .eq('id', gameData.id);
        if (gameUpdateError) throw gameUpdateError;
        const players = [...(gameData.team_a || []), ...(gameData.team_b || [])];
        const statUpdatePromises = players.map(async (player) => {
          try {
            const profile = await getUserProfile(player.user_id);
            if (!profile) {
              console.warn(`Profile not found for ${player.user_id}, skipping stats update.`);
              return;
            }
            const updates = {
              games_played: (profile.games_played || 0) + 1,
              total_points_scored: (profile.total_points_scored || 0) + 5 + (player.user_id === mvpUserId ? 10 : 0),
              mvp_awards: (profile.mvp_awards || 0) + (player.user_id === mvpUserId ? 1 : 0)
            };
            const { error: updateError } = await updateUserProfile(player.user_id, updates);
            if (updateError) {
              console.error(`Error updating profile stats for ${player.user_id}:`, updateError);
            }
          } catch(statError) {
            console.error(`Unexpected error updating stats for player ${player.user_id}:`, statError);
          }
        });
        await Promise.all(statUpdatePromises);
        console.log("Game ended successfully and stats updated.");
      } catch (error) {
        console.error("Error ending game:", error);
        if (currentScreen === 'active') {
          setScoreErrorMessage("Error finalizing game. Please try again later.");
        }
      }
    };

    const sendChatMessage = async (message) => {
      if (!supabase || !currentUser || !currentGameData || !message.trim()) return;
      if (!userProfile || !userProfile.username) {
        userProfile = await getUserProfile(currentUser.id);
        if (!userProfile || !userProfile.username) {
          console.error("User profile/username not loaded. Cannot send chat.");
          alert("Please ensure your username is set in your profile to send chat messages.");
          return;
        }
      }
      const newMessage = {
        user_id: currentUser.id,
        username: userProfile.username,
        message: message.trim(),
        timestamp: new Date().toISOString()
      };
      const currentChatLog = currentGameData.chat_log || [];
      const updatedChatLog = [...currentChatLog, newMessage];
      renderChatMessages(updatedChatLog);
      scrollToChatBottom();
      chatInput.value = '';
      try {
        const { error } = await supabase
          .from('games')
          .update({ chat_log: updatedChatLog })
          .eq('id', currentGameId);
        if (error) throw error;
        currentGameData.chat_log = updatedChatLog;
      } catch (error) {
        console.error("Error sending chat message:", error);
        renderChatMessages(currentChatLog);
        alert("Failed to send message. Please try again.");
        chatInput.value = message;
      }
    };

    const fetchProfileData = async (userId) => {
      if (!supabase) return;
      showElement(profileLoader);
      hideElement(profileContent);
      try {
        const profile = await getUserProfile(userId);
        renderProfile(profile);
      } catch (error) {
        console.error("Error loading profile screen:", error);
        hideElement(profileLoader);
        profileContent.innerHTML = `<p class="error-text p-2 text-center">Failed to load profile data.</p>`;
        showElement(profileContent);
      }
    };

    const loadGameHistory = async (userId) => {
      if (!supabase) return;
      showElement(gameHistoryLoader);
      hideElement(noHistoryMessage);
      gameHistoryList.innerHTML = '';
      try {
        const { data, error } = await supabase
          .from('games')
          .select('*')
          .eq('status', 'finished')
          .order('created_at', { ascending: false })
          .limit(50);
        if (error) throw error;
        const userHistory = data.filter(game =>
          game.team_a?.some(p => p.user_id === userId) ||
          game.team_b?.some(p => p.user_id === userId)
        );
        renderGameHistory(userHistory);
      } catch (error) {
        console.error("Error fetching game history:", error);
        hideElement(gameHistoryLoader);
        showElement(noHistoryMessage);
        noHistoryMessage.textContent = "Could not load game history.";
      }
    };

    // --- New: Fetch Leaderboard with Location Filtering ---
    const fetchLeaderboard = async () => {
      if (!supabase) return;
      showElement(leaderboardLoader);
      hideElement(noLeaderboardMessage);
      leaderboardList.innerHTML = '';
      try {
        let query = supabase
          .from('profiles')
          .select('user_id, username, total_points_scored, games_played, mvp_awards')
          .order('total_points_scored', { ascending: false, nullsFirst: false })
          .limit(50);

        const filterType = locationFilter.value;
        if (filterType !== 'global') {
          // Only add filter if we have location details
          if (filterType === 'city' && userCity) {
            query = query.eq('city', userCity);
          } else if (filterType === 'state' && userState) {
            query = query.eq('state', userState);
          } else if (filterType === 'country' && userCountry) {
            query = query.eq('country', userCountry);
          }
        }

        const { data, error } = await query;
        if (error) throw error;
        renderLeaderboard(data);
      } catch (error) {
        console.error("Error fetching leaderboard:", error);
        hideElement(leaderboardLoader);
        showElement(noLeaderboardMessage);
        noLeaderboardMessage.textContent = "Could not load leaderboard.";
      }
    };

    // --- REALTIME SUBSCRIPTIONS ---
    const subscribeToGamesList = () => {
      if (!supabase) return;
      unsubscribeFromGamesList();
      console.log("Subscribing to games list changes...");
      gamesSubscription = supabase.channel('public:games-list')
        .on('postgres_changes',
          { event: '*', schema: 'public', table: 'games' },
          (payload) => {
            console.log('Change received on games table (list view)!', payload);
            if (currentScreen === 'main') {
              console.log("Re-fetching games list due to change.");
              fetchGames();
            }
          }
        )
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
            console.log('Successfully subscribed to games list!');
          }
          if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            console.error('Games list subscription error:', status, err);
          }
          if (status === 'CLOSED') {
            console.log('Games list subscription closed.');
          }
        });
    };

    const unsubscribeFromGamesList = () => {
      if (gamesSubscription) {
        console.log("Unsubscribing from games list.");
        supabase.removeChannel(gamesSubscription).catch(err => console.error("Error removing games list channel:", err));
        gamesSubscription = null;
      }
    };

    const subscribeToGame = (gameId) => {
      if (!supabase || !gameId) return;
      unsubscribeFromGame();
      console.log(`Subscribing to game ${gameId}...`);
      const channelName = `game-${gameId}`;
      gameSubscription = supabase.channel(channelName)
        .on('postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'games',
            filter: `id=eq.${gameId}`
          },
          (payload) => {
            console.log(`Game ${gameId} updated!`, payload);
            const updatedGame = payload.new;
            const oldGame = payload.old;
            currentGameData = updatedGame;
            if (currentScreen === 'detail') {
              if (updatedGame.status === 'pending') {
                renderGameDetail(updatedGame);
              } else if (updatedGame.status === 'active') {
                navigateTo('active');
                renderActiveGame(updatedGame);
              } else if (updatedGame.status === 'finished') {
                navigateTo('end');
                renderGameEnd(updatedGame);
              } else if (updatedGame.status === 'cancelled') {
                alert("This game has been cancelled.");
                navigateTo('main');
                fetchGames();
              }
            } else if (currentScreen === 'active') {
              if (updatedGame.status === 'active') {
                renderActiveGame(updatedGame);
                checkAndApplyScore(updatedGame);
              } else if (updatedGame.status === 'finished') {
                navigateTo('end');
                renderGameEnd(updatedGame);
              } else if (updatedGame.status === 'cancelled') {
                alert("This game has been cancelled.");
                navigateTo('main');
                fetchGames();
              }
            }
            if (JSON.stringify(updatedGame.chat_log) !== JSON.stringify(oldGame?.chat_log)) {
              if (currentScreen === 'detail' || currentScreen === 'active') {
                renderChatMessages(updatedGame.chat_log || []);
              }
            }
          }
        )
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
            console.log(`Successfully subscribed to game ${gameId}!`);
          }
          if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            console.error(`Game ${gameId} subscription error:`, status, err);
            if (currentScreen === 'detail' || currentScreen === 'active') {
              alert("Real-time connection lost. Some updates might be delayed.");
            }
          }
          if (status === 'CLOSED') {
            console.log(`Game ${gameId} subscription closed.`);
          }
        });
    };

    const unsubscribeFromGame = () => {
      if (gameSubscription) {
        const channelName = gameSubscription.channelName;
        console.log(`Unsubscribing from ${channelName}.`);
        supabase.removeChannel(gameSubscription).catch(err => console.error(`Error removing ${channelName} channel:`, err));
        gameSubscription = null;
      }
    };

    // --- AUTHENTICATION LOGIC ---
    const handleAuth = async (event) => {
      event.preventDefault();
      if (!supabase) return;
      const isSignUp = authSubmitBtn.textContent === 'Sign Up';
      const email = emailInput.value.trim();
      const password = passwordInput.value;
      const uname = usernameInput.value.trim();
      authError.textContent = '';
      disableElement(authSubmitBtn);
      try {
        if (isSignUp) {
          if (!uname || uname.length < 3) {
            throw new Error("Username must be at least 3 characters long.");
          }
          const { data: signUpData, error: signUpError } = await supabase.auth.signUp({ email, password });
          if (signUpError) throw signUpError;
          if (!signUpData.user) throw new Error("Signup succeeded but no user data returned.");
          console.log("SignUp successful, user created:", signUpData.user.id);
          const { data: profileData, error: profileError } = await createInitialUserProfile(signUpData.user.id, email, uname);
          if (profileError) {
            console.error("Profile creation failed after signup:", profileError);
            throw new Error(`Account created, but profile setup failed: ${profileError.message}. Please check your email verification and try logging in.`);
          }
          userProfile = profileData;
          currentUser = signUpData.user;
          alert("Sign up successful! Please check your email for verification link before logging in.");
          authForm.reset();
        } else {
          const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({ email, password });
          if (signInError) {
            if (signInError.message.includes("Email not confirmed")) {
              authError.textContent = "Please confirm your email address by clicking the link sent to you before logging in.";
            } else {
              throw signInError;
            }
          } else if (signInData.user) {
            currentUser = signInData.user;
            await checkUserSession();
          } else {
            throw new Error("Login attempt failed: No user data received.");
          }
        }
      } catch (error) {
        console.error('Auth error:', error);
        authError.textContent = error.message || 'An unexpected error occurred.';
      } finally {
        enableElement(authSubmitBtn);
      }
    };

    const handleLogout = async () => {
      if (!supabase) return;
      console.log("Logging out...");
      unsubscribeFromGame();
      unsubscribeFromGamesList();
      currentGameId = null;
      currentGameData = null;
      const { error } = await supabase.auth.signOut();
      if (error) {
        console.error("Error logging out:", error);
        alert("Error logging out. Please try again.");
      } else {
        currentUser = null;
        userProfile = null;
        navigateTo('auth');
        authTitle.textContent = 'Login to HoopsLink';
        authSubmitBtn.textContent = 'Login';
        authToggleText.textContent = "Don't have an account?";
        authToggleBtn.textContent = 'Sign Up';
        hideElement(usernameField);
        authForm.reset();
        authError.textContent = '';
        console.log("User logged out successfully.");
      }
    };

    const toggleAuthMode = () => {
      const isSignUp = authSubmitBtn.textContent === 'Sign Up';
      if (isSignUp) {
        authTitle.textContent = 'Login to HoopsLink';
        authSubmitBtn.textContent = 'Login';
        authToggleText.textContent = "Don't have an account?";
        authToggleBtn.textContent = 'Sign Up';
        hideElement(usernameField);
      } else {
        authTitle.textContent = 'Sign Up for HoopsLink';
        authSubmitBtn.textContent = 'Sign Up';
        authToggleText.textContent = 'Already have an account?';
        authToggleBtn.textContent = 'Login';
        showElement(usernameField);
      }
      authError.textContent = '';
      authForm.reset();
      enableElement(authSubmitBtn);
    };

    const checkUserSession = async () => {
      if (!supabase) {
        navigateTo('auth');
        hideElement(screens.loading);
        return;
      }
      try {
        console.log("Checking user session...");
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) {
          console.error("Error getting session:", error);
          navigateTo('auth');
        } else if (session && session.user) {
          currentUser = session.user;
          console.log("User session found:", currentUser.id);
          if (!userProfile || userProfile.user_id !== currentUser.id) {
            userProfile = await getUserProfile(currentUser.id);
          }
          if (!userProfile) {
            console.warn("User session exists, but profile not found for user:", currentUser.id);
            alert("Could not load your profile data. You may need to complete profile setup.");
            navigateTo('main');
            fetchGames();
          } else {
            console.log("User profile loaded:", userProfile.username);
            if (currentScreen === 'auth' || currentScreen === 'loading') {
              navigateTo('main');
              fetchGames();
            }
          }
        } else {
          console.log("No active user session found.");
          if (currentScreen !== 'auth') {
            navigateTo('auth');
          }
        }
      } catch (err) {
        console.error("Unexpected error checking session:", err);
        if (currentScreen !== 'auth') {
          navigateTo('auth');
        }
      } finally {
        hideElement(screens.loading);
      }
    };

    // --- EVENT HANDLERS ---
    function handleGameItemClick(gameId) {
      console.log("Clicked game:", gameId);
      currentGameId = gameId;
      navigateTo('detail');
      fetchGameDetails(gameId);
    }

    function handleCreateGameSubmit(event) {
      event.preventDefault();
      const locationInput = document.getElementById('game-location');
      const dateTimeInput = document.getElementById('game-datetime');
      const submitButton = event.target.querySelector('button[type="submit"]');
      const location = locationInput.value;
      const dateTime = dateTimeInput.value;
      createGameError.textContent = '';
      disableElement(submitButton);
      createGame(location, dateTime).then(({ data, error }) => {
        enableElement(submitButton);
        if (error) {
          createGameError.textContent = error.message;
        } else {
          console.log("Game created:", data);
          toggleCreateGameModal(false);
        }
      });
    }

    function handleJoinLeaveClick() {
      if (!currentGameId) return;
      const action = joinLeaveGameBtn.textContent;
      if (action === 'Join Game') {
        joinGame(currentGameId);
      } else if (action === 'Leave Game') {
        if (confirm("Are you sure you want to leave this game?")) {
          leaveGame(currentGameId);
        }
      }
    }

    function handleBeginGameClick() {
      if (!currentGameId) return;
      if (confirm(`Ready to start the game with ${currentGameData?.players?.length || 0} players? This will randomize teams.`)) {
        beginGame(currentGameId);
      }
    }

    function handleCancelGameClick() {
      if (!currentGameId) return;
      cancelGame(currentGameId);
    }

    function handleScoreClick(event) {
      if (!event.target.classList.contains('score')) return;
      const team = event.target.dataset.team;
      proposeScore(team);
    }

    function handleProfileUpdate(event) {
      event.preventDefault();
      const newUsername = editProfileUsernameInput.value.trim();
      profileUpdateError.textContent = '';
      profileUpdateMessage.textContent = '';
      if (!newUsername || newUsername.length < 3) {
        profileUpdateError.textContent = "Username must be at least 3 characters.";
        return;
      }
      if (userProfile && newUsername === userProfile.username) {
        toggleProfileEdit(false);
        return;
      }
      disableElement(saveProfileBtn);
      updateUserProfile(currentUser.id, { username: newUsername })
        .then(({ data, error }) => {
          enableElement(saveProfileBtn);
          if (error) {
            console.error("Profile update error:", error);
            profileUpdateError.textContent = `Update failed: ${error.message}`;
          } else {
            userProfile = data;
            renderProfile(userProfile);
            profileUpdateMessage.textContent = "Profile updated successfully!";
            toggleProfileEdit(false);
            setTimeout(() => profileUpdateMessage.textContent = '', 3000);
          }
        });
    }

    function handleSendChat(event) {
      event.preventDefault();
      const message = chatInput.value;
      sendChatMessage(message);
    }

    // --- UI TOGGLES AND HELPERS ---
    function toggleCreateGameModal(show) {
      if (show) {
        createGameModal.classList.add('visible');
        document.getElementById('game-location').focus();
      } else {
        createGameModal.classList.remove('visible');
        createGameForm.reset();
        createGameError.textContent = '';
      }
    }

    function toggleProfileEdit(editing) {
      if (editing) {
        hideElement(profileUsername);
        hideElement(editProfileBtn);
        showElement(editProfileUsernameInput);
        showElement(saveProfileBtn);
        editProfileUsernameInput.focus();
      } else {
        showElement(profileUsername);
        showElement(editProfileBtn);
        hideElement(editProfileUsernameInput);
        hideElement(saveProfileBtn);
        profileUpdateError.textContent = '';
      }
    }

    function toggleChatDrawer(open) {
      if (open) {
        chatDrawer.classList.add('open');
        scrollToChatBottom();
      } else {
        chatDrawer.classList.remove('open');
      }
    }

    function scrollToChatBottom() {
      requestAnimationFrame(() => {
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    function showShareModal(textToShare, urlToShare) {
      const defaultUrl = window.location.href;
      const url = urlToShare || defaultUrl;
      const text = textToShare || "Check out this game on HoopsLink!";
      shareLinkInput.value = url;
      if (navigator.share) {
        showElement(webShareApiBtn);
        webShareApiBtn.onclick = async () => {
          try {
            await navigator.share({
              title: 'HoopsLink Game',
              text: text,
              url: url,
            });
            console.log('Successful share');
            toggleShareModal(false);
          } catch (error) {
            console.error('Error sharing:', error);
          }
        };
      } else {
        hideElement(webShareApiBtn);
      }
      shareModal.classList.add('visible');
    }

    function toggleShareModal(show) {
      if (!show) {
        shareModal.classList.remove('visible');
      }
    }

    function copyShareLink() {
      shareLinkInput.select();
      shareLinkInput.setSelectionRange(0, 99999);
      try {
        navigator.clipboard.writeText(shareLinkInput.value).then(() => {
          copyShareLinkBtn.textContent = 'Copied!';
          setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
        }).catch(err => {
          console.error('Failed to copy using Clipboard API: ', err);
          oldCopyFallback();
        });
      } catch (err) {
        console.error('Clipboard API not available, using fallback: ', err);
        oldCopyFallback();
      }
    }

    function oldCopyFallback() {
      try {
        document.execCommand('copy');
        copyShareLinkBtn.textContent = 'Copied!';
        setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
      } catch (err) {
        console.error('Fallback execCommand failed: ', err);
        copyShareLinkBtn.textContent = 'Copy Failed';
        setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
      }
    }

    // --- CONFETTI LOGIC ---
    let confettiInterval = null;
    function startConfetti() {
      stopConfetti();
      confettiContainer.innerHTML = '';
      const colors = [varToString('--primary-color'), varToString('--secondary-color'), varToString('--accent-color'), '#FFFFFF'];
      for (let i = 0; i < 50; i++) {
        createConfettiParticle(colors);
      }
      confettiInterval = setInterval(() => {
        if (currentScreen !== 'end') {
          stopConfetti();
          return;
        }
        createConfettiParticle(colors);
      }, 150);
    }
    function createConfettiParticle(colors) {
      const confetti = document.createElement('div');
      confetti.classList.add('confetti');
      confetti.style.left = `${Math.random() * 100}vw`;
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDuration = `${Math.random() * 2 + 3}s`;
      confetti.style.opacity = `${Math.random() * 0.5 + 0.5}`;
      const scale = Math.random() * 0.5 + 0.5;
      confetti.style.transform = `scale(${scale})`;
      confetti.style.width = `${10 * scale}px`;
      confetti.style.height = `${20 * scale}px`;
      confettiContainer.appendChild(confetti);
      confetti.addEventListener('animationend', () => {
        confetti.remove();
      });
    }
    function stopConfetti() {
      clearInterval(confettiInterval);
      confettiInterval = null;
    }
    function varToString(varName) {
      if (document.documentElement) {
        return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      }
      return '#FF6B00';
    }

    // --- INITIALIZATION ---
    function initApp() {
      console.log("Initializing HoopsLink App...");
      if (!supabase) {
        console.error("Supabase client not initialized.");
        hideElement(screens.loading);
        authError.textContent = "Application configuration error. Supabase connection failed.";
        authTitle.textContent = "Configuration Error";
        disableElement(authSubmitBtn);
        disableElement(authToggleBtn);
        navigateTo('auth');
        return;
      }
      authForm.addEventListener('submit', handleAuth);
      authToggleBtn.addEventListener('click', toggleAuthMode);
      logoutBtn.addEventListener('click', handleLogout);
      createGameFab.addEventListener('click', () => toggleCreateGameModal(true));
      createGameForm.addEventListener('submit', handleCreateGameSubmit);
      joinLeaveGameBtn.addEventListener('click', handleJoinLeaveClick);
      beginGameBtn.addEventListener('click', handleBeginGameClick);
      cancelGameBtn.addEventListener('click', handleCancelGameClick);
      shareGameBtn.addEventListener('click', () => {
        if (currentGameData) {
          const shareText = `Join my basketball game "${currentGameData.location_name || 'Unnamed Game'}" on HoopsLink!`;
          const shareUrl = window.location.href;
          showShareModal(shareText, shareUrl);
        }
      });
      activeGameContent.addEventListener('click', handleScoreClick);
      confirmScoreBtn.addEventListener('click', confirmScoreProposal);
      rejectScoreBtn.addEventListener('click', rejectScoreProposal);
      profileNavBtn.addEventListener('click', () => {
        if (currentUser) {
          navigateTo('profile');
          fetchProfileData(currentUser.id);
        } else {
          navigateTo('auth');
        }
      });
      leaderboardNavBtn.addEventListener('click', () => {
        navigateTo('leaderboard');
        fetchLeaderboard();
      });
      editProfileBtn.addEventListener('click', () => toggleProfileEdit(true));
      saveProfileBtn.addEventListener('click', handleProfileUpdate);
      backBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          navigateTo('main');
          fetchGames();
        });
      });
      toggleChatBtn.addEventListener('click', () => toggleChatDrawer(true));
      activeGameToggleChatBtn.addEventListener('click', () => toggleChatDrawer(true));
      closeChatBtn.addEventListener('click', () => toggleChatDrawer(false));
      sendChatBtn.addEventListener('click', handleSendChat);
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          handleSendChat(e);
        }
      });
      copyShareLinkBtn.addEventListener('click', copyShareLink);
      // Leaderboard filter listener
      locationFilter.addEventListener('change', fetchLeaderboard);

      supabase.auth.onAuthStateChange(async (event, session) => {
        console.log('Auth State Change:', event, session);
        const previousUserId = currentUser?.id;
        currentUser = session?.user ?? null;
        if (event === 'SIGNED_IN') {
          console.log("Signed in, checking/loading profile...");
          if (!userProfile || userProfile.user_id !== currentUser.id) {
            userProfile = await getUserProfile(currentUser.id);
          }
          if (userProfile) {
            console.log("Profile loaded:", userProfile.username);
            if (currentScreen === 'auth') {
              navigateTo('main');
              fetchGames();
            }
          } else {
            console.error("Profile missing for user:", currentUser?.id);
            alert("Login successful, but failed to load profile data. Please try refreshing or check your profile.");
            if (currentScreen === 'auth') {
              navigateTo('main');
              fetchGames();
            }
          }
        } else if (event === 'SIGNED_OUT') {
          console.log("Signed out.");
          userProfile = null;
          currentUser = null;
          if (currentScreen !== 'auth') {
            handleLogout();
          }
        } else if (event === 'USER_UPDATED') {
          console.log("User data updated. Fetching updated profile...");
          if (currentUser) {
            userProfile = await getUserProfile(currentUser.id);
            if (currentScreen === 'profile') {
              renderProfile(userProfile);
            }
          }
        } else if (event === 'TOKEN_REFRESHED') {
          console.log("Auth token refreshed.");
          if (!currentUser && session?.user) {
            console.warn("Token refreshed but user missing. Re-checking session.");
            await checkUserSession();
          }
        }
        if (currentUser?.id !== previousUserId && previousUserId != null) {
          console.log("User ID changed, resetting game state.");
          unsubscribeFromGame();
          unsubscribeFromGamesList();
          currentGameId = null;
          currentGameData = null;
          toggleChatDrawer(false);
        }
      });
      checkUserSession();
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
