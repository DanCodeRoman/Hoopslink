<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HoopsLink - Find Your Game</title>
    <!-- Include Supabase JS Library (v2) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* --- Global Styles & Variables --- */
        :root {
            --primary-color: #ff6b00; /* Energetic Orange */
            --secondary-color: #4a00e0; /* Vibrant Purple */
            --accent-color: #00f2a9; /* Electric Teal */
            --background-color: #121212; /* Dark Container Background */
            --surface-color: #1e1e1e; /* Slightly Lighter Surface */
            --text-color: #e0e0e0; /* Light Text */
            --text-color-dark: #111111; /* Dark Text for light backgrounds */
            --success-color: #00d18b;
            --error-color: #ff4d4d;
            --font-family: 'Poppins', sans-serif; /* Playful but clean font */
            --border-radius: 12px;
            --box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            --transition-speed: 0.3s;
            --transition-effect: ease-in-out;
        }

        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
           height: 100%;
        }

        body {
            min-height: 100%; /* Ensure body takes full height */
            font-family: var(--font-family);
            background-color: #000000; /* Website background black */
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px; /* Add some padding around the container on large screens */
            font-size: 16px;
            /* Make text non-selectable by default */
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE10+/Edge */
        }

        /* Allow text selection in inputs and textareas */
        input, textarea {
            user-select: auto;
            -webkit-user-select: auto;
            -moz-user-select: text; /* Older Firefox might need text */
            -ms-user-select: auto;
        }


        #app-container {
            width: 100%;
            max-width: 900px;
            min-height: 600px;
            height: auto; /* Allow height to grow */
            max-height: 95vh; /* Limit height */
            background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Still hide overflow for transitions */
            position: relative;
            margin: auto; /* Center container */
        }

        /* --- Screen Management --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Screens still fill the container */
            background-color: var(--background-color);
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-speed) var(--transition-effect), transform var(--transition-speed) var(--transition-effect);
            transform: translateX(100%);
            display: flex;
            flex-direction: column;
            z-index: 1;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
            z-index: 10;
        }

        /* Specific screen transitions */
        #auth-screen.active { transform: translateX(0); }
        #loading-screen.active { transform: scale(1); opacity: 1; z-index: 100; }
        #main-app-screen.active { transform: translateX(0); }
        #game-detail-screen.active { transform: translateX(0); }
        #active-game-screen.active { transform: scale(1); opacity: 1; }
        #game-end-screen.active { transform: translateY(0); opacity: 1; }
        #profile-screen.active { transform: translateX(0); }
        #leaderboard-screen.active { transform: translateX(0); }

        #loading-screen {
            transform: scale(1.1);
            transition: opacity var(--transition-speed) ease-out, transform var(--transition-speed) ease-out;
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
         #loading-screen h1.logo {
             font-size: 3rem;
             font-weight: 900;
             color: #FFFFFF; /* White color */
             background: none; /* Remove gradient */
             -webkit-background-clip: unset;
             text-shadow: 2px 2px 5px rgba(0,0,0,0.5); /* Optional shadow */
         }


        #game-end-screen {
            transform: translateY(100%);
        }

        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .bold { font-weight: bold; }
        .primary-text { color: var(--primary-color); }
        .secondary-text { color: var(--secondary-color); }
        .accent-text { color: var(--accent-color); }
        .error-text { color: var(--error-color); font-size: 0.9em; margin-top: 5px; }
        .success-text { color: var(--success-color); }
        .flex-col { display: flex; flex-direction: column; }
        .flex-row { display: flex; flex-direction: row; }
        .flex-center { display: flex; justify-content: center; align-items: center; }
        .flex-grow { flex-grow: 1; }
        .space-between { justify-content: space-between; }
        .align-center { align-items: center; }
        .p-1 { padding: 1rem; }
        .p-2 { padding: 2rem; }
        .m-1 { margin: 1rem; }
        .mt-1 { margin-top: 1rem; }
        .mb-1 { margin-bottom: 1rem; }
        .ml-1 { margin-left: 1rem; }
        .mr-1 { margin-right: 1rem; }
        .gap-1 { gap: 1rem; }
        .gap-05 { gap: 0.5rem; }
        .w-full { width: 100%; }


        /* --- Basic Elements Styling --- */
        button, input[type="submit"] {
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: transform var(--transition-speed) var(--transition-effect), background-color var(--transition-speed) var(--transition-effect), box-shadow var(--transition-speed) var(--transition-effect);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        button::before, input[type="submit"]::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s ease-out, height 0.5s ease-out;
            z-index: -1;
        }

        button:active::before, input[type="submit"]:active::before {
            width: 300px;
            height: 300px;
        }

        button:hover, input[type="submit"]:hover {
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        button:active, input[type="submit"]:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--primary-color), #ffa040);
            color: var(--text-color-dark);
        }

        .btn-secondary {
            background: linear-gradient(45deg, var(--secondary-color), #8a2be2);
            color: var(--text-color);
        }
        .btn-accent {
            background: linear-gradient(45deg, var(--accent-color), #00c896);
            color: var(--text-color-dark);
        }

        .btn-danger {
            background: linear-gradient(45deg, var(--error-color), #ff6f6f);
            color: var(--text-color);
        }

        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }
        .btn-outline:hover {
            background-color: var(--primary-color);
            color: var(--text-color-dark);
        }

        /* Style for active filter button */
        .filter-btn.active {
            background-color: var(--primary-color);
            color: var(--text-color-dark);
            font-weight: bold;
        }


        input[type="text"], input[type="email"], input[type="password"], input[type="datetime-local"], textarea {
            width: 100%;
            padding: 12px 15px;
            background-color: var(--surface-color);
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color var(--transition-speed) var(--transition-effect), box-shadow var(--transition-speed);
        }

        input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus, input[type="datetime-local"]:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 107, 0, 0.3);
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--accent-color);
        }

        h1, h2, h3 {
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
        h1 {
            font-size: 2.5rem;
            line-height: 1.1;
            color: #FFFFFF; /* Made H1 white */
            font-weight: 900;
            background: none;
            -webkit-background-clip: unset;
        }
        h2 { font-size: 1.8rem; color: var(--primary-color); }
        h3 { font-size: 1.4rem; color: var(--secondary-color); }

        hr {
            border: none;
            height: 1px;
            background-color: var(--surface-color);
            margin: 1rem 0;
        }

        /* --- Header / Navbar --- */
        .app-header {
            padding: 1rem;
            background-color: var(--surface-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 50;
             /* Sticky header within the container */
            position: sticky;
            top: 0;
            border-top-left-radius: var(--border-radius); /* Match container radius */
            border-top-right-radius: var(--border-radius);
        }

        .app-header .logo {
            font-size: 1.5rem;
            font-weight: 900;
            color: #FFFFFF; /* Logo color white */
            background: none;
            -webkit-background-clip: unset;
            cursor: pointer;
        }


        .header-actions button {
            background: none;
            border: none;
            color: var(--accent-color);
            font-size: 1.5rem;
            cursor: pointer;
            margin-left: 1rem;
            padding: 5px;
            transition: color var(--transition-speed), transform var(--transition-speed);
        }
        .header-actions button:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }

        /* --- Content Area --- */
        /* This is now the main scrollable area WITHIN each screen */
        .screen > .content-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem; /* Default padding */
            /* Custom scrollbar */
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--surface-color);
        }
        .screen > .content-area::-webkit-scrollbar {
            width: 8px;
        }
        .screen > .content-area::-webkit-scrollbar-track {
            background: var(--surface-color);
            border-radius: 10px;
        }
        .screen > .content-area::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
            border: 2px solid var(--surface-color);
        }

        /* --- Loading Spinner --- */
        .loader {
            border: 6px solid var(--surface-color);
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Specific Screen Styles --- */

        /* Auth Screen */
        #auth-screen {
            background: linear-gradient(180deg, var(--secondary-color) 0%, var(--background-color) 70%);
            justify-content: center; /* Keep content centered vertically */
            align-items: center; /* Keep content centered horizontally */
            padding: 2rem;
            height: 100%; /* Ensure it takes full container height */
        }
        #auth-form-container {
            background-color: rgba(30, 30, 30, 0.8);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            width: 100%;
            max-width: 380px; /* Slightly wider auth box */
            backdrop-filter: blur(5px);
            margin: auto; /* Center horizontally */
        }
        #auth-form-container h2 {
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .auth-toggle {
            margin-top: 1rem;
            text-align: center;
        }
        .auth-toggle button {
            background: none;
            border: none;
            color: var(--primary-color);
            text-decoration: underline;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Main App Screen (Game List) */
        #main-app-screen > .content-area { padding: 0; } /* List items have padding */
        #game-list {
            list-style: none;
            padding: 1rem 0; /* Add padding top/bottom */
        }
        .game-list-item {
            background-color: var(--surface-color);
            margin: 1rem; /* Keep margin */
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            border-left: 5px solid var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed), border-color var(--transition-speed);
            animation: slideInUp 0.5s var(--transition-effect) backwards;
            opacity: 0;
             /* Link animation delay to variable */
            animation-delay: calc(var(--animation-order, 0) * 0.05s);
        }

        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .game-list-item:hover {
            transform: translateX(5px) scale(1.02);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-left-color: var(--accent-color);
        }
        .game-info h3 { margin-bottom: 0.3rem; color: var(--text-color); font-size: 1.2rem; }
        .game-meta { font-size: 0.9rem; color: #aaa; }
        .game-status-indicator {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        .status-pending { background-color: var(--primary-color); color: var(--text-color-dark); }
        .status-active { background-color: var(--success-color); color: var(--text-color-dark); }
        .status-finished { background-color: var(--secondary-color); color: var(--text-color); }
        .status-cancelled { background-color: var(--error-color); color: var(--text-color); } /* Added cancelled */


        #create-game-fab {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            color: var(--text-color-dark);
            font-size: 2rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            z-index: 20;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #create-game-fab:hover {
            transform: scale(1.1) rotate(90deg);
        }

        /* Create Game Modal */
        #create-game-modal {
            position: fixed; /* Changed to fixed for better overlay */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease;
            backdrop-filter: blur(5px);
        }
        #create-game-modal.visible {
            opacity: 1;
            visibility: visible;
        }
        #create-game-form-container {
            background-color: var(--surface-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            width: 90%;
            max-width: 450px; /* Slightly larger modal */
            transform: scale(0.9);
            transition: transform var(--transition-speed) cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #create-game-modal.visible #create-game-form-container {
            transform: scale(1);
        }

        /* Game Detail / Lobby Screen */
        #game-detail-screen > .content-area,
        #active-game-screen > .content-area {
            padding: 1.5rem;
        }
        #game-detail-header h2 {
             color: var(--primary-color);
             background: none;
             -webkit-background-clip: unset;
             margin-bottom: 0.5rem;
        }
        #game-detail-meta span { margin-right: 1rem; color: #ccc; font-size: 0.9rem; }
        #player-list { list-style: none; padding: 0; }
        .player-list-item {
            background-color: var(--surface-color);
            padding: 10px 15px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: fadeIn 0.5s ease forwards;
            opacity: 0;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: var(--text-color);
        }
        .player-username { font-weight: 600; }
        .player-status { margin-left: auto; font-size: 0.8rem; color: #aaa; }
        #game-actions { max-width: 300px; margin: 1rem auto 0 auto; } /* Center buttons */
        #game-actions button { width: 100%; margin-top: 10px; }

        /* Active Game Screen */
        #active-game-screen {
            background: linear-gradient(180deg, #222 0%, var(--background-color) 80%);
        }
        #active-game-screen .app-header { /* Allow space for timer */
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #game-timer {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent-color);
            padding: 0 1rem; /* Adjust padding */
            min-width: 70px; /* Ensure space */
            text-align: center;
        }
        .scoreboard {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: rgba(0,0,0,0.3);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            max-width: 500px; margin-left: auto; margin-right: auto; /* Center scoreboard */
        }
        .team-score { text-align: center; }
        .team-name { font-size: 1rem; font-weight: 600; margin-bottom: 5px; color: #aaa; }
        .score {
            font-size: 3rem;
            font-weight: 900;
            line-height: 1;
            transition: transform 0.3s ease, color 0.3s ease;
            cursor: pointer; /* Keep cursor to indicate clickability */
        }
        .score:hover { transform: scale(1.1); }
        #team-a-score { color: var(--primary-color); }
        #team-b-score { color: var(--accent-color); }
        .vs { font-size: 1.5rem; font-weight: bold; color: var(--text-color); }

        .team-display { display: flex; gap: 1rem; margin-top: 1rem; max-width: 700px; margin-left: auto; margin-right: auto; /* Center team display */ }
        .team-column {
            flex: 1;
            background-color: var(--surface-color);
            padding: 1rem;
            border-radius: var(--border-radius);
        }
        .team-column h4 { margin-bottom: 1rem; text-align: center; }
        #team-a-list h4 { color: var(--primary-color); }
        #team-b-list h4 { color: var(--accent-color); }
        .team-player {
            font-size: 0.9rem;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        .team-player:last-child { border-bottom: none; }

        #score-confirmation-modal {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--surface-color);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 1rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            transform: translate(-50%, 20px);
        }
        #score-confirmation-modal.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%);
        }
        #score-confirmation-modal button {
            padding: 8px 15px;
            font-size: 0.9rem;
        }

        /* Game End Screen */
        #game-end-screen {
            background: linear-gradient(180deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            justify-content: center; /* Vertically center */
            align-items: center; /* Horizontally center */
            text-align: center;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }
        #game-end-summary {
            background-color: rgba(30, 30, 30, 0.8);
            padding: 2.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            backdrop-filter: blur(5px);
            animation: zoomIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            opacity: 0;
            max-width: 500px; /* Limit width */
            width: 90%;
        }
        @keyframes zoomIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        #game-end-summary h2 { color: var(--accent-color); font-size: 2.5rem; }
        #final-score { font-size: 1.8rem; margin-bottom: 1.5rem; }
        #mvp-highlight {
            background-color: rgba(0,0,0,0.3);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            border: 2px solid var(--accent-color);
        }
        #mvp-highlight h3 { color: var(--accent-color); margin-bottom: 0.5rem; font-size: 1.2rem; }
        #mvp-username { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
        #mvp-score { font-size: 1rem; color: #ccc; }
        #game-end-actions button { margin: 0.5rem; }

        /* Confetti */
        .confetti {
            position: absolute;
            width: 10px;
            height: 20px;
            background-color: var(--primary-color);
            opacity: 0.7;
            animation: confetti-fall 4s linear infinite;
            pointer-events: none; /* Prevent interaction */
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotateZ(0deg); opacity: 0.7; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0; }
        }
         #confetti-container { /* Ensure container covers screen */
             position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; z-index: 0;
         }

        /* Profile Screen */
        #profile-screen > .content-area { padding: 2rem; }
        #profile-header { text-align: center; margin-bottom: 1rem; }
        #profile-avatar {
            width: 120px; height: 120px; border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            margin: 0 auto 1rem auto; display: flex; justify-content: center; align-items: center;
            font-size: 4rem; font-weight: bold; color: var(--text-color);
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
             /* In a real app, add an upload icon/button here */
        }
        #profile-username-display { display: inline-block; margin-bottom: 0.5rem; }
        #profile-username { font-size: 1.8rem; font-weight: bold; }
        #edit-profile-btn, #save-profile-btn {
            background: none; border: none; color: var(--accent-color); cursor: pointer;
            font-size: 0.9rem; margin-left: 10px; vertical-align: middle; padding: 5px; /* Added padding */
        }
        #save-profile-btn { font-weight: bold; } /* Make save button clearer */

        #profile-edit-fields {
            max-width: 350px; margin: 0 auto 1.5rem auto;
            display: flex; flex-direction: column; gap: 1rem;
        }
        #profile-email { font-size: 0.9em; color: #aaa; margin-bottom: 1rem;}

        #profile-stats {
            background-color: var(--surface-color); padding: 1.5rem; border-radius: var(--border-radius);
            margin-top: 1.5rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem; max-width: 600px; margin-left: auto; margin-right: auto;
        }
        .stat-item { text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
        .stat-label { font-size: 0.9rem; color: #aaa; }

        #game-history-list { margin-top: 1.5rem; list-style: none; padding: 0; max-width: 700px; margin-left: auto; margin-right: auto; }
        .history-item { background-color: var(--surface-color); padding: 1rem; border-radius: var(--border-radius); margin-bottom: 1rem; border-left: 4px solid var(--secondary-color); }
        .history-details { font-size: 0.9em; color: #ccc; margin-bottom: 5px; }
        .history-score { font-weight: bold; }
        .history-result { font-weight: bold; }
        .result-win { color: var(--success-color); }
        .result-loss { color: var(--error-color); }

        /* Leaderboard Screen */
        #leaderboard-screen > .content-area { padding: 0; display: flex; flex-direction: column; }
         #leaderboard-filters { padding: 0.5rem 1rem; background-color: var(--surface-color); text-align: center; border-bottom: 1px solid var(--background-color); display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
         #leaderboard-filters button { padding: 8px 15px; font-size: 0.9rem; background-color: transparent; border: 1px solid var(--primary-color); color: var(--primary-color); transition: background-color 0.2s ease, color 0.2s ease; }
         #leaderboard-filters button:hover { background-color: rgba(255, 107, 0, 0.2); transform: none; box-shadow: none; }
         #leaderboard-filters button.active { background-color: var(--primary-color); color: var(--text-color-dark); font-weight: bold; border-color: var(--primary-color); }
         #leaderboard-status { text-align: center; padding: 0.5rem; font-size: 0.9em; color: var(--accent-color); }

        #leaderboard-list-container { flex-grow: 1; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--primary-color) var(--surface-color); }
        #leaderboard-list-container::-webkit-scrollbar { width: 8px; }
        #leaderboard-list-container::-webkit-scrollbar-track { background: var(--surface-color); border-radius: 10px; }
        #leaderboard-list-container::-webkit-scrollbar-thumb { background-color: var(--primary-color); border-radius: 10px; border: 2px solid var(--surface-color); }

        #leaderboard-list { list-style: none; padding: 1rem 0; max-width: 700px; margin: 0 auto;}
        .leaderboard-item { display: flex; align-items: center; padding: 1rem; margin: 0 1rem 1rem 1rem; background-color: var(--surface-color); border-radius: var(--border-radius); position: relative; transition: transform 0.2s ease-in-out; animation: fadeIn 0.5s ease forwards; opacity: 0; animation-delay: calc(var(--animation-order, 0) * 0.05s); }
        .leaderboard-item:hover { transform: scale(1.03); }
        .leaderboard-rank { font-size: 1.2rem; font-weight: bold; color: var(--primary-color); width: 40px; text-align: center; margin-right: 1rem; }
        .leaderboard-item:nth-child(1) .leaderboard-rank { color: #ffd700; font-size: 1.6rem; }
        .leaderboard-item:nth-child(2) .leaderboard-rank { color: #c0c0c0; font-size: 1.4rem; }
        .leaderboard-item:nth-child(3) .leaderboard-rank { color: #cd7f32; font-size: 1.3rem; }
        .leaderboard-avatar { width: 45px; height: 45px; border-radius: 50%; background-color: var(--secondary-color); display: flex; justify-content: center; align-items: center; font-weight: bold; color: var(--text-color); margin-right: 1rem; }
        .leaderboard-info { flex-grow: 1; }
        .leaderboard-username { font-weight: 600; }
        .leaderboard-stat { font-size: 0.9rem; color: #aaa; }
        .leaderboard-score { font-size: 1.1rem; font-weight: bold; color: var(--accent-color); }

        /* Chat */
        #chat-drawer { position: fixed; bottom: 0; right: 0; width: 350px; height: 60%; max-height: 450px; background-color: var(--surface-color); border-top-left-radius: var(--border-radius); border-bottom-left-radius: var(--border-radius); box-shadow: -10px 0 30px rgba(0,0,0,0.5); transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.165, 0.84, 0.44, 1); z-index: 900; display: flex; flex-direction: column; padding: 1rem; }
        #chat-drawer.open { transform: translateX(0); }
        #chat-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #444; }
        #chat-header h3 { margin-bottom: 0; color: var(--accent-color); }
        #close-chat-btn { background: none; border: none; color: var(--text-color); font-size: 1.5rem; cursor: pointer; }
        #chat-messages { flex-grow: 1; overflow-y: auto; margin-bottom: 1rem; scrollbar-width: thin; scrollbar-color: var(--secondary-color) var(--background-color); }
        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: var(--background-color); border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb { background-color: var(--secondary-color); border-radius: 10px; }
        .chat-message { margin-bottom: 0.8rem; display: flex; flex-direction: column; max-width: 90%; animation: popIn 0.3s ease forwards; opacity: 0; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .chat-message.own { align-self: flex-end; align-items: flex-end; }
        .message-bubble { padding: 8px 12px; border-radius: var(--border-radius); background-color: #333; color: var(--text-color); word-wrap: break-word; }
        .chat-message.own .message-bubble { background: linear-gradient(45deg, var(--primary-color), #ffa040); color: var(--text-color-dark); }
        .message-meta { font-size: 0.75rem; color: #aaa; margin-top: 3px; }
        .chat-message.own .message-meta { text-align: right; }
        .message-sender { font-weight: bold; margin-right: 5px; }
        #chat-input-area { display: flex; gap: 10px; }
        #chat-input { flex-grow: 1; background-color: #444; border: none; }
        #chat-input:focus { box-shadow: none; border: 1px solid var(--secondary-color); }

        /* Modal Base */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease; backdrop-filter: blur(5px); }
        .modal.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--surface-color); padding: 2rem; border-radius: var(--border-radius); box-shadow: var(--box-shadow); width: 90%; max-width: 450px; transform: scale(0.9); transition: transform var(--transition-speed) cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; }
        .modal.visible .modal-content { transform: scale(1); }
        .modal-close-btn { position: absolute; top: 10px; right: 10px; background: none; border: none; color: var(--text-color); font-size: 1.8rem; cursor: pointer; line-height: 1; padding: 5px; }

        /* Share Modal */
        #share-options button { display: block; width: 100%; margin-bottom: 10px; text-align: left; padding: 12px 15px; background-color: #444; color: var(--text-color); }
        #share-options button:hover { background-color: #555; transform: none; box-shadow: none; }
        #share-link-input { margin-top: 1rem; }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Loading Screen -->
        <div id="loading-screen" class="screen active">
            <h1 class="logo">HoopsLink</h1>
            <div class="loader mt-1"></div>
            <p class="mt-1">Finding your court...</p>
        </div>

        <!-- Auth Screen -->
        <div id="auth-screen" class="screen flex-col">
            <div id="auth-form-container">
                <h2 id="auth-title">Login to HoopsLink</h2>
                <form id="auth-form">
                    <div class="mb-1">
                        <label for="email">Email</label>
                        <input type="email" id="email" required>
                    </div>
                    <div class="mb-1">
                        <label for="password">Password</label>
                        <input type="password" id="password" required>
                    </div>
                    <div id="username-field" class="mb-1 hidden">
                        <label for="username">Username</label>
                        <input type="text" id="username" minlength="3">
                        <small style="font-size: 0.8em; color: #aaa;">Min 3 characters, used for display.</small>
                    </div>
                    <div id="auth-error" class="error-text mb-1"></div>
                    <button type="submit" id="auth-submit-btn" class="btn-primary w-full">Login</button>
                </form>
                <div class="auth-toggle">
                    <span id="auth-toggle-text">Don't have an account?</span>
                    <button id="auth-toggle-btn">Sign Up</button>
                </div>
            </div>
        </div>

        <!-- Main App Screen (Game List) -->
        <div id="main-app-screen" class="screen flex-col">
            <header class="app-header">
                <div class="logo">HoopsLink</div>
                <div class="header-actions">
                    <button id="leaderboard-nav-btn" title="Leaderboard"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M120-120v-150h150v150H120Zm0-270v-150h150v150H120Zm0-270v-150h150v150H120Zm270 270v-150h150v150H390Zm0-270v-150h150v150H390Zm270 540v-150h150v150H660Zm0-270v-150h150v150H660Zm0-270v-150h150v150H660Zm-270 0v-150h150v150H390Z"/></svg></button>
                    <button id="profile-nav-btn" title="Profile"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"/></svg></button>
                    <button id="logout-btn" title="Logout"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v120H200v560h280v120H200Zm440-160-55-58 102-102H360v-120h327L585-662l55-58 200 200-200 200Z"/></svg></button>
                </div>
            </header>
            <div class="content-area">
                <h2 class="text-center p-1">Upcoming Games</h2>
                <div id="game-list-loader" class="loader hidden"></div>
                <ul id="game-list"></ul>
                <p id="no-games-message" class="text-center mt-2 hidden">No games found. Why not create one?</p>
            </div>
            <button id="create-game-fab" title="Create Game">+</button>
        </div>

        <!-- Game Detail / Lobby Screen -->
        <div id="game-detail-screen" class="screen flex-col">
            <header class="app-header">
                <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
                <div class="logo">Game Lobby</div>
                <div></div><!-- Spacer -->
            </header>
            <div class="content-area">
                <div id="game-detail-loader" class="loader"></div>
                <div id="game-detail-content" class="hidden">
                    <div id="game-detail-header">
                        <h2 id="game-detail-location">Location Name</h2>
                        <div id="game-detail-meta" class="mb-1">
                            <span id="game-detail-datetime">📅 Time</span>
                            <span id="game-detail-creator">👑 Created by User</span>
                        </div>
                        <div id="game-detail-status" class="mb-1 bold">Status: <span class="status-indicator">Pending</span></div>
                    </div>
                    <hr>
                    <h3>Players (<span id="player-count">0</span>/<span id="max-players">10</span>)</h3>
                    <ul id="player-list" class="mb-1"></ul>
                    <div id="game-actions">
                        <button id="join-leave-game-btn" class="btn-primary w-full">Join Game</button>
                        <button id="begin-game-btn" class="btn-secondary hidden w-full">Begin Game (Creator Only)</button>
                        <button id="cancel-game-btn" class="btn-danger hidden w-full">Cancel Game (Creator Only)</button>
                        <button id="share-game-btn" class="btn-accent mt-1 w-full">Share Game</button>
                    </div>
                    <div id="game-detail-error" class="error-text mt-1 text-center"></div> <!-- Centered error -->
                    <hr>
                    <button id="toggle-chat-btn" class="btn-outline w-full mt-1" style="max-width: 200px; margin-left: auto; margin-right:auto;">Show Chat</button>
                </div>
            </div>
        </div>

        <!-- Active Game Screen -->
        <div id="active-game-screen" class="screen flex-col">
            <header class="app-header">
                <div class="logo" style="font-size: 1.2rem;">Active Game</div>
                <!-- ADDED Game Timer Display -->
                <div id="game-timer">--:--</div>
                <button id="active-game-toggle-chat-btn" class="btn-outline" style="padding: 5px 10px; font-size: 0.9rem;">Chat</button>
            </header>
            <div class="content-area">
                <div id="active-game-loader" class="loader"></div>
                <div id="active-game-content" class="hidden">
                    <div class="scoreboard">
                        <div class="team-score">
                            <div class="team-name">Team A</div>
                            <div id="team-a-score" class="score" data-team="A">0</div>
                        </div>
                        <div class="vs">VS</div>
                        <div class="team-score">
                            <div class="team-name">Team B</div>
                            <div id="team-b-score" class="score" data-team="B">0</div>
                        </div>
                    </div>
                    <p id="score-proposal-message" class="text-center mb-1 success-text hidden"></p>
                    <p id="score-error-message" class="text-center mb-1 error-text hidden"></p>
                    <div class="team-display">
                        <div id="team-a-list" class="team-column">
                            <h4>Team A</h4>
                        </div>
                        <div id="team-b-list" class="team-column">
                            <h4>Team B</h4>
                        </div>
                    </div>
                    <p class="text-center mt-2" style="font-size: 0.9em; color: #aaa;">Click score to propose +1 point.</p>
                </div>
            </div>
            <!-- Score Confirmation Modal - remains fixed -->
            <div id="score-confirmation-modal" class="">
                <p id="score-confirm-text">Confirm +1 for Team X?</p>
                <button id="confirm-score-btn" class="btn-success">Confirm</button>
                <button id="reject-score-btn" class="btn-danger">Reject</button>
            </div>
        </div>

        <!-- Game End Screen -->
        <div id="game-end-screen" class="screen flex-col">
             <div id="confetti-container"></div> <!-- For confetti effect -->
             <div id="game-end-summary">
                 <h2 id="game-end-title">Game Over!</h2>
                 <p id="final-score" class="bold">Team A: 10 - Team B: 8</p>
                 <div id="mvp-highlight" class="hidden"> <!-- Hide by default -->
                     <h3>🏆 Top Scorer (MVP) 🏆</h3>
                     <p id="mvp-username" class="bold">MVP_User</p>
                     <p id="mvp-score">Scored X points</p>
                 </div>
                 <div id="game-end-actions" class="flex-col gap-05">
                     <button id="back-to-main-btn" class="btn-primary">Back to Games</button>
                     <button id="view-leaderboard-btn" class="btn-secondary">View Leaderboard</button>
                     <button id="share-results-btn" class="btn-accent">Share Results</button>
                 </div>
            </div>
        </div>

        <!-- Profile Screen -->
        <div id="profile-screen" class="screen flex-col">
            <header class="app-header">
                <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
                <div class="logo">Your Profile</div>
                <div></div><!-- Spacer -->
            </header>
            <div class="content-area">
                <div id="profile-loader" class="loader"></div>
                <div id="profile-content" class="hidden">
                    <div id="profile-header">
                        <div id="profile-avatar">U</div> <!-- Placeholder: Add image upload functionality here -->
                        <!-- Username Display Area -->
                        <div id="profile-username-display">
                            <span id="profile-username" class="bold">Username</span>
                            <button id="edit-profile-btn">✏️</button>
                        </div>
                         <!-- Edit Fields (Initially Hidden) -->
                        <div id="profile-edit-fields" class="hidden">
                             <div class="mb-1">
                                  <label for="edit-profile-username-input">Username</label>
                                  <input type="text" id="edit-profile-username-input" placeholder="New username" minlength="3">
                             </div>
                             <div class="mb-1">
                                  <label for="edit-profile-city">City</label>
                                  <input type="text" id="edit-profile-city" placeholder="Your City">
                             </div>
                             <div class="mb-1">
                                  <label for="edit-profile-state">State / Province</label>
                                  <input type="text" id="edit-profile-state" placeholder="Your State/Province">
                             </div>
                             <div class="mb-1">
                                  <label for="edit-profile-country">Country</label>
                                  <input type="text" id="edit-profile-country" placeholder="Your Country">
                             </div>
                             <button id="save-profile-btn" class="btn-primary mt-1">💾 Save Changes</button>
                        </div>
                        <div id="profile-email" style="font-size: 0.9em; color: #aaa;">user@example.com</div>
                    </div>

                    <!-- Status Messages -->
                    <div id="profile-update-message" class="success-text text-center mt-1"></div>
                    <div id="profile-update-error" class="error-text text-center mt-1"></div>

                    <!-- Stats Area -->
                    <div id="profile-stats">
                        <div class="stat-item">
                            <div id="profile-stat-points" class="stat-value">0</div>
                            <div class="stat-label">Total Points</div>
                        </div>
                        <div class="stat-item">
                            <div id="profile-stat-games" class="stat-value">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-item">
                            <div id="profile-stat-mvp" class="stat-value">0</div>
                            <div class="stat-label">MVP Awards</div>
                        </div>
                    </div>
                    <hr style="max-width: 700px; margin-left: auto; margin-right: auto;">
                    <h3 class="text-center">Game History</h3>
                    <div id="game-history-loader" class="loader hidden"></div>
                    <ul id="game-history-list"></ul>
                    <p id="no-history-message" class="text-center mt-1 hidden">No completed games yet.</p>
                </div>
            </div>
        </div>


        <!-- Leaderboard Screen -->
        <div id="leaderboard-screen" class="screen flex-col">
            <header class="app-header">
                <button class="back-btn" style="background:none; border:none; font-size: 1.5rem; color: var(--accent-color); cursor:pointer;">&lt;</button>
                <div class="logo">Leaderboard</div>
                 <div class="header-actions"> <!-- Optional: Move chat toggle here -->
                     <button id="leaderboard-chat-toggle" title="Chat (Global/Local?)" class="hidden"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M800-80v-640q0-33-23.5-56.5T720-799H240q-33 0-56.5 23.5T160-720v480q0 33 23.5 56.5T240-160h400l160 160v-80Zm-80-80H240v-480h480v480Zm-40-140H280v-80h360v80Zm0-120H280v-80h360v80Z"/></svg></button>
                 </div>
            </header>
            <!-- Filter Controls -->
            <div id="leaderboard-filters">
                 <button class="filter-btn active" data-scope="global">Global</button>
                 <button class="filter-btn" data-scope="country">My Country</button>
                 <button class="filter-btn" data-scope="state">My State</button>
                 <button class="filter-btn" data-scope="city">My City</button>
             </div>
             <div id="leaderboard-status" class="p-1 text-center accent-text">Showing Global Leaders</div>

            <div id="leaderboard-list-container"> <!-- Added scrollable container -->
                <div id="leaderboard-loader" class="loader"></div>
                <ul id="leaderboard-list"></ul>
                <p id="no-leaderboard-message" class="text-center mt-2 hidden">Leaderboard is empty for this filter.</p>
            </div>
        </div>

        <!-- Chat Drawer (Positioned right) -->
        <div id="chat-drawer">
            <div id="chat-header">
                <h3 id="chat-title">Game Chat</h3> <!-- Add ID to change title -->
                <button id="close-chat-btn">&times;</button>
            </div>
            <div id="chat-messages"></div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type your message...">
                <button id="send-chat-btn" class="btn-secondary">Send</button>
            </div>
        </div>

        <!-- Create Game Modal -->
        <div id="create-game-modal" class="modal">
            <div id="create-game-form-container" class="modal-content">
                <button class="modal-close-btn" onclick="toggleCreateGameModal(false)">&times;</button>
                <h2>Create New Game</h2>
                <form id="create-game-form">
                    <div class="mb-1">
                        <label for="game-location">Location Name</label>
                        <input type="text" id="game-location" required>
                    </div>
                    <div class="mb-1">
                        <label for="game-datetime">Date & Time</label>
                        <input type="datetime-local" id="game-datetime" required>
                    </div>
                    <div id="create-game-error" class="error-text mb-1"></div>
                    <button type="submit" class="btn-primary w-full">Create Game</button>
                </form>
            </div>
        </div>

        <!-- Share Modal -->
        <div id="share-modal" class="modal">
            <div class="modal-content">
                <button class="modal-close-btn" onclick="toggleShareModal(false)">&times;</button>
                <h2>Share Game</h2>
                <div id="share-options">
                    <p class="mb-1">Share this game link:</p>
                    <input type="text" id="share-link-input" readonly>
                    <button id="copy-share-link-btn" class="mt-1">Copy Link</button>
                    <button id="web-share-api-btn" class="hidden">Share via...</button>
                </div>
            </div>
        </div>

    </div> <!-- End #app-container -->

    <script>
        // --- SUPABASE CLIENT SETUP ---
        // IMPORTANT: Replace with your actual Supabase URL and Anon Key
        const SUPABASE_URL = 'https://aghnqhwhpiwndronbgkd.supabase.co'; // <- Replace this
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFnaG5xaHdocGl3bmRyb25iZ2tkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5MDM4NTMsImV4cCI6MjA1OTQ3OTg1M30.jwYaXa_nb5HXQHjA3Bt6NUxYwQPDTawzNJvkOtI4Y1Q'; // <- Replace this

        let supabase = null;

        if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
            if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
                try {
                    supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    console.log("Supabase client initialized successfully.");
                } catch (error) { console.error("Error initializing Supabase client:", error); alert("DB connection error."); supabase = null; }
            } else { console.error("Supabase URL/Key not configured."); alert("App config error."); }
        } else { console.error("Supabase library failed to load!"); alert("Critical Error: DB library missing."); }

        // --- APPLICATION STATE ---
        let currentUser = null;
        let userProfile = null; // Holds {user_id, username, email, city, state, country, ...stats}
        let currentScreen = 'loading';
        let currentGameId = null;
        let currentGameData = null;
        let gameSubscription = null;
        let gamesSubscription = null;
        let scoreProposals = {};
        let currentScoreProposal = null;
        let confirmingScore = false; // Prevents double clicks during confirmation
        let leaderboardScope = 'global';
        let leaderboardFilterValue = null;
        let gameTimerInterval = null; // For active game timer

        // --- CONSTANTS ---
        const GAME_DURATION_MINUTES = 10; // Default game length
        const SCORE_LIMIT = 11; // Score needed to win (unless time runs out)
        const MIN_PLAYERS_TO_START = 4; // Minimum players required to begin a game

        // --- UI ELEMENTS CACHE (Add new elements) ---
        const screens = { loading: document.getElementById('loading-screen'), auth: document.getElementById('auth-screen'), main: document.getElementById('main-app-screen'), detail: document.getElementById('game-detail-screen'), active: document.getElementById('active-game-screen'), end: document.getElementById('game-end-screen'), profile: document.getElementById('profile-screen'), leaderboard: document.getElementById('leaderboard-screen'), };
        const authForm = document.getElementById('auth-form'); const authTitle = document.getElementById('auth-title'); const authSubmitBtn = document.getElementById('auth-submit-btn'); const authToggleBtn = document.getElementById('auth-toggle-btn'); const authToggleText = document.getElementById('auth-toggle-text'); const usernameField = document.getElementById('username-field'); const usernameInput = document.getElementById('username'); const emailInput = document.getElementById('email'); const passwordInput = document.getElementById('password'); const authError = document.getElementById('auth-error'); const logoutBtn = document.getElementById('logout-btn'); const gameList = document.getElementById('game-list'); const gameListLoader = document.getElementById('game-list-loader'); const noGamesMessage = document.getElementById('no-games-message'); const createGameFab = document.getElementById('create-game-fab'); const createGameModal = document.getElementById('create-game-modal'); const createGameForm = document.getElementById('create-game-form'); const createGameError = document.getElementById('create-game-error'); const gameDetailLoader = document.getElementById('game-detail-loader'); const gameDetailContent = document.getElementById('game-detail-content'); const gameDetailLocation = document.getElementById('game-detail-location'); const gameDetailDatetime = document.getElementById('game-detail-datetime'); const gameDetailCreator = document.getElementById('game-detail-creator'); const gameDetailStatus = document.getElementById('game-detail-status').querySelector('.status-indicator'); const playerCount = document.getElementById('player-count'); const maxPlayers = document.getElementById('max-players'); const playerList = document.getElementById('player-list'); const joinLeaveGameBtn = document.getElementById('join-leave-game-btn'); const beginGameBtn = document.getElementById('begin-game-btn'); const cancelGameBtn = document.getElementById('cancel-game-btn'); const shareGameBtn = document.getElementById('share-game-btn'); const gameDetailError = document.getElementById('game-detail-error'); const activeGameLoader = document.getElementById('active-game-loader'); const activeGameContent = document.getElementById('active-game-content'); const teamAScore = document.getElementById('team-a-score'); const teamBScore = document.getElementById('team-b-score'); const teamAList = document.getElementById('team-a-list'); const teamBList = document.getElementById('team-b-list'); const scoreProposalMessage = document.getElementById('score-proposal-message'); const scoreErrorMessage = document.getElementById('score-error-message'); const scoreConfirmationModal = document.getElementById('score-confirmation-modal'); const scoreConfirmText = document.getElementById('score-confirm-text'); const confirmScoreBtn = document.getElementById('confirm-score-btn'); const rejectScoreBtn = document.getElementById('reject-score-btn'); const gameEndScreen = document.getElementById('game-end-screen'); const gameEndTitle = document.getElementById('game-end-title'); const finalScore = document.getElementById('final-score'); const mvpUsername = document.getElementById('mvp-username'); const mvpScore = document.getElementById('mvp-score'); const mvpHighlight = document.getElementById('mvp-highlight'); const confettiContainer = document.getElementById('confetti-container'); const backToMainBtn = document.getElementById('back-to-main-btn'); const viewLeaderboardBtn = document.getElementById('view-leaderboard-btn'); const shareResultsBtn = document.getElementById('share-results-btn'); const profileLoader = document.getElementById('profile-loader'); const profileContent = document.getElementById('profile-content'); const profileAvatar = document.getElementById('profile-avatar'); const profileUsernameDisplay = document.getElementById('profile-username-display'); const profileUsername = document.getElementById('profile-username'); const profileEmail = document.getElementById('profile-email'); const editProfileBtn = document.getElementById('edit-profile-btn'); const saveProfileBtn = document.getElementById('save-profile-btn'); const profileEditFields = document.getElementById('profile-edit-fields'); const editProfileUsernameInput = document.getElementById('edit-profile-username-input'); const editProfileCityInput = document.getElementById('edit-profile-city'); const editProfileStateInput = document.getElementById('edit-profile-state'); const editProfileCountryInput = document.getElementById('edit-profile-country'); const profileUpdateMessage = document.getElementById('profile-update-message'); const profileUpdateError = document.getElementById('profile-update-error'); const profileStatPoints = document.getElementById('profile-stat-points'); const profileStatGames = document.getElementById('profile-stat-games'); const profileStatMvp = document.getElementById('profile-stat-mvp'); const gameHistoryLoader = document.getElementById('game-history-loader'); const gameHistoryList = document.getElementById('game-history-list'); const noHistoryMessage = document.getElementById('no-history-message'); const leaderboardLoader = document.getElementById('leaderboard-loader'); const leaderboardListContainer = document.getElementById('leaderboard-list-container'); const leaderboardList = document.getElementById('leaderboard-list'); const noLeaderboardMessage = document.getElementById('no-leaderboard-message'); const leaderboardFilters = document.getElementById('leaderboard-filters'); const leaderboardStatus = document.getElementById('leaderboard-status'); const profileNavBtn = document.getElementById('profile-nav-btn'); const leaderboardNavBtn = document.getElementById('leaderboard-nav-btn'); const backBtns = document.querySelectorAll('.back-btn'); const chatDrawer = document.getElementById('chat-drawer'); const chatMessages = document.getElementById('chat-messages'); const chatInput = document.getElementById('chat-input'); const sendChatBtn = document.getElementById('send-chat-btn'); const closeChatBtn = document.getElementById('close-chat-btn'); const toggleChatBtn = document.getElementById('toggle-chat-btn'); const activeGameToggleChatBtn = document.getElementById('active-game-toggle-chat-btn'); const shareModal = document.getElementById('share-modal'); const shareLinkInput = document.getElementById('share-link-input'); const copyShareLinkBtn = document.getElementById('copy-share-link-btn'); const webShareApiBtn = document.getElementById('web-share-api-btn');
        const gameTimerDisplay = document.getElementById('game-timer'); // Added Game Timer Element

        // --- UTILITY FUNCTIONS ---
        const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => { func.apply(this, args); }, delay); }; };
        const formatDate = (dateString) => { if (!dateString) return 'Date TBD'; try { const date = new Date(dateString); const now = new Date(); const tomorrow = new Date(now); tomorrow.setDate(now.getDate() + 1); const optionsTime = { hour: 'numeric', minute: 'numeric', hour12: true }; const optionsDate = { month: 'short', day: 'numeric' }; if (date.toDateString() === now.toDateString()) return `Today, ${date.toLocaleTimeString('en-US', optionsTime)}`; else if (date.toDateString() === tomorrow.toDateString()) return `Tomorrow, ${date.toLocaleTimeString('en-US', optionsTime)}`; else return `${date.toLocaleDateString('en-US', optionsDate)}, ${date.toLocaleTimeString('en-US', optionsTime)}`; } catch (e) { console.error("Date format error:", e); return "Invalid Date"; } };
        const showElement = (el) => el?.classList.remove('hidden'); const hideElement = (el) => el?.classList.add('hidden'); const enableElement = (el) => { if(el) el.disabled = false; }; const disableElement = (el) => { if(el) el.disabled = true; };

        const navigateTo = (screenName) => {
             if (!screens[screenName]) { console.error("Unknown screen:", screenName); return; }
             console.log(`Navigating from ${currentScreen} to ${screenName}`);

             // Stop timer if leaving active game screen
             if (currentScreen === 'active' && screenName !== 'active') {
                 stopGameTimer();
             }

             // Unsubscribe from specific game if leaving detail/active/end
             if (['detail', 'active', 'end'].includes(currentScreen) && !['detail', 'active', 'end'].includes(screenName)) {
                unsubscribeFromGame();
                currentGameId = null;
                currentGameData = null;
             }
             // Unsubscribe from list if leaving main
             if (currentScreen === 'main' && screenName !== 'main') {
                unsubscribeFromGamesList();
             }
             // Close chat if navigating away from game context
             if (!['detail', 'active'].includes(screenName)) {
                toggleChatDrawer(false);
             }

             Object.values(screens).forEach(s => s.classList.remove('active'));
             screens[screenName].classList.add('active');
             currentScreen = screenName;
         };

        const getUserAvatarText = (username) => username ? username.charAt(0).toUpperCase() : '?';

        const getUserProfile = async (userId) => {
             if (!supabase || !userId) return null;
             try {
                 // console.log("Fetching profile:", userId); // Less verbose logging
                 const { data, error, status } = await supabase.from('profiles').select('*').eq('user_id', userId).single();
                 if (error && status !== 406) { // 406 means no rows found, which is ok for checking existence
                    console.error('Fetch profile error:', error);
                    return null;
                 }
                 // console.log("Profile fetched:", data); // Less verbose logging
                 return data;
             } catch (error) {
                 console.error('Fetch profile exception:', error);
                 return null;
             }
         };
        const updateUserProfile = async (userId, updates) => {
             if (!supabase || !userId) return { error: { message: 'Client/ID missing' } };
             try {
                 const { data, error } = await supabase.from('profiles').update(updates).eq('user_id', userId).select().single(); return { data, error };
             } catch (error) { console.error('Update profile error:', error); return { error }; }
         };
        const createInitialUserProfile = async (userId, email, username) => {
             if (!supabase) return { error: { message: 'Client missing' } }; console.log(`Creating profile for ${userId}, user: ${username}`);
             try {
                 // Check if username exists first
                 const { data: existingUser, error: checkError } = await supabase.from('profiles').select('username').eq('username', username).maybeSingle();
                 if (checkError && checkError.code !== 'PGRST116') { // PGRST116 means 0 rows, expected if username is free
                    console.error('Username check error:', checkError);
                    // Allow creation attempt even if check fails, insert might handle uniqueness
                 }
                 if (existingUser) {
                     console.warn(`Username ${username} taken.`);
                     return { error: { message: 'Username already taken. Please choose another.' } };
                 }

                 // Insert new profile
                 const { data, error } = await supabase.from('profiles').insert({ user_id: userId, email: email, username: username }).select().single();
                 if (error) {
                     console.error('Insert profile error:', error);
                     // Check for unique constraint violation specifically
                     if (error.code === '23505' && error.message.includes('profiles_username_key')) {
                        return { error: { message: 'Username already taken. Please choose another.' } };
                     }
                     return { error }; // Return other errors
                 }
                 console.log(`Profile created ${userId}:`, data);
                 return { data, error: null }; // Ensure error is null on success
             } catch (error) {
                 console.error('Create profile exception:', error);
                 return { error };
             }
         };

        // --- SCREEN RENDERING FUNCTIONS ---
        const renderGameList = (games) => {
             gameList.innerHTML = ''; hideElement(gameListLoader); if (!games || games.length === 0) { showElement(noGamesMessage); return; } hideElement(noGamesMessage);
             // Sort: pending first, then by start time
             games.sort((a, b) => {
                 if (a.status === 'pending' && b.status !== 'pending') return -1;
                 if (a.status !== 'pending' && b.status === 'pending') return 1;
                 if (a.status === 'active' && b.status !== 'active') return -1; // Active before finished/cancelled
                 if (a.status !== 'active' && b.status === 'active') return 1;
                 const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                 const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                 return timeA - timeB;
             });
             games.forEach((game, index) => {
                 const li = document.createElement('li'); li.classList.add('game-list-item'); li.dataset.gameId = game.id; li.style.setProperty('--animation-order', index);
                 const players = game.players || []; // Players only relevant for pending
                 const playerCount = players.length;
                 const maxP = 10; // Max players constant?
                 let statusText = game.status ? game.status.charAt(0).toUpperCase() + game.status.slice(1) : 'Unknown';
                 if (game.status === 'pending') {
                    statusText = `${playerCount}/${maxP} Players`;
                 }
                 li.innerHTML = `<div class="game-info"><h3>${game.location_name || 'Unnamed Game'}</h3><div class="game-meta"><span>📍 ${game.location_name || 'TBD'}</span> | <span>📅 ${formatDate(game.start_time)}</span></div></div><div class="game-status-indicator status-${game.status || 'unknown'}">${statusText}</div>`;
                 li.addEventListener('click', () => handleGameItemClick(game.id)); gameList.appendChild(li);
             });
             requestAnimationFrame(() => { document.querySelectorAll('.game-list-item').forEach(item => { item.style.opacity = '1'; item.style.transform = 'translateY(0)'; }); });
         };
        const renderGameDetail = (game) => {
             hideElement(gameDetailLoader); if (!game) { gameDetailError.textContent = "Failed to load game details."; showElement(gameDetailError); hideElement(gameDetailContent); return; } showElement(gameDetailContent); hideElement(gameDetailError);
             currentGameData = game; // Update global state
             gameDetailLocation.textContent = game.location_name || 'Unnamed Game'; gameDetailDatetime.textContent = `📅 ${formatDate(game.start_time)}`; gameDetailCreator.textContent = `👑 Loading Creator...`; fetchUserProfileAndSetCreator(game.creator_id);
             const statusClass = `status-${game.status || 'unknown'}`; gameDetailStatus.className = `status-indicator ${statusClass}`; gameDetailStatus.textContent = game.status ? game.status.charAt(0).toUpperCase() + game.status.slice(1) : 'Unknown';
             const players = game.players || []; // Only pending games have 'players' field populated typically
             playerCount.textContent = players.length;
             maxPlayers.textContent = '10'; // Assuming fixed max players
             playerList.innerHTML = '';
             players.forEach(player => { const li = document.createElement('li'); li.classList.add('player-list-item'); li.innerHTML = `<div class="player-avatar">${getUserAvatarText(player.username)}</div><span class="player-username">${player.username || 'Guest'}</span><span class="player-status">${player.user_id === game.creator_id ? 'Creator' : ''}</span>`; playerList.appendChild(li); });
             updateGameDetailButtons(game);
             // Only show chat if game is pending or active
             if (game.status === 'pending' || game.status === 'active') {
                showElement(toggleChatBtn);
                if (chatDrawer.classList.contains('open')) {
                    renderChatMessages(game.chat_log || []);
                }
             } else {
                hideElement(toggleChatBtn);
                toggleChatDrawer(false); // Close chat if game ended/cancelled
             }
         };
        const fetchUserProfileAndSetCreator = async (creatorId) => { const profile = await getUserProfile(creatorId); if (profile?.username) { gameDetailCreator.textContent = `👑 Created by ${profile.username}`; } else { gameDetailCreator.textContent = `👑 Creator ID: ${creatorId ? creatorId.substring(0, 8) : 'Unknown'}...`; } };
        const updateGameDetailButtons = (game) => {
             if (!currentUser || !game) return;
             const isCreator = game.creator_id === currentUser.id;
             const players = game.players || []; // Use players array for pending games
             const isPlayer = players.some(p => p.user_id === currentUser.id);

             const canJoin = players.length < 10 && !isPlayer && game.status === 'pending';
             const canLeave = isPlayer && game.status === 'pending' && !isCreator; // Creator cannot leave pending game via button
             const canBegin = isCreator && game.status === 'pending' && players.length >= MIN_PLAYERS_TO_START;
             const canCancel = isCreator && game.status === 'pending';

             // Reset all button states first
             hideElement(joinLeaveGameBtn);
             hideElement(beginGameBtn);
             hideElement(cancelGameBtn);
             hideElement(shareGameBtn);

             if (game.status === 'pending') {
                if (canJoin) { joinLeaveGameBtn.textContent = 'Join Game'; joinLeaveGameBtn.className = 'btn-primary w-full'; showElement(joinLeaveGameBtn); enableElement(joinLeaveGameBtn); }
                else if (canLeave) { joinLeaveGameBtn.textContent = 'Leave Game'; joinLeaveGameBtn.className = 'btn-danger w-full'; showElement(joinLeaveGameBtn); enableElement(joinLeaveGameBtn); }
                // If already joined and not creator, show nothing or maybe 'Joined'? For now, hide if cannot leave/join.
                else if (isPlayer && !canLeave) { /* Maybe show a disabled 'Joined' button? */ }

                if (canBegin) { showElement(beginGameBtn); enableElement(beginGameBtn); }
                if (canCancel) { showElement(cancelGameBtn); enableElement(cancelGameBtn); }
                showElement(shareGameBtn); // Allow sharing pending games
             } else if (game.status === 'active') {
                // No join/leave/begin/cancel buttons for active games from detail screen (user should be on active screen)
                showElement(shareGameBtn); // Allow sharing active games
             }
             // No actions for finished/cancelled games on detail screen
         };
        const renderActiveGame = (game) => {
             hideElement(activeGameLoader); if (!game || game.status !== 'active') { console.warn("Render active game called with invalid state:", game?.status); navigateTo('main'); fetchGames(); return; } showElement(activeGameContent);
             currentGameData = game; // Update global state
             teamAScore.textContent = game.score_a || 0; teamBScore.textContent = game.score_b || 0;
             const renderTeam = (el, teamData, name) => { el.innerHTML = `<h4>${name}</h4>`; const players = teamData || []; if (players.length === 0) { el.innerHTML += `<p style="font-size: 0.8em; color: #888; text-align: center;">No players assigned.</p>`; } else { players.forEach(p => { const div = document.createElement('div'); div.classList.add('team-player'); div.textContent = p.username || `User ${p.user_id.substring(0,6)}`; el.appendChild(div); }); } };
             renderTeam(teamAList, game.team_a, 'Team A'); renderTeam(teamBList, game.team_b, 'Team B');
             updateScoreProposalUI(game.point_proposals);
             // Start or update the game timer
             startGameTimer(game.game_end_time);
             // Update chat if open
             if (chatDrawer.classList.contains('open')) {
                renderChatMessages(game.chat_log || []);
             }
         };
        const renderGameEnd = (game) => {
             if (!game || !['finished', 'cancelled'].includes(game.status)) { console.error("Render Game End called with invalid game data or status."); return; }
             hideElement(activeGameLoader); // Ensure loader is hidden
             stopGameTimer(); // Ensure timer is stopped
             stopConfetti(); // Stop previous confetti
             showElement(gameEndScreen);

             const scoreA = game.score_a || 0;
             const scoreB = game.score_b || 0;
             let title = "Game Over!";
             let background = 'linear-gradient(180deg, var(--surface-color) 0%, var(--background-color) 100%)'; // Default/Draw/Cancelled

             if (game.status === 'finished') {
                 const winner = game.winner;
                 if (winner === 'A') { title = 'Team A Wins!'; background = 'linear-gradient(180deg, var(--primary-color) 0%, #8A2BE2 100%)'; }
                 else if (winner === 'B') { title = 'Team B Wins!'; background = 'linear-gradient(180deg, var(--accent-color) 0%, var(--secondary-color) 100%)'; }
                 else { title = 'It\'s a Draw!'; }
                 finalScore.textContent = `Final Score: ${scoreA} - ${scoreB}`;
                 showElement(finalScore);

                 // Show MVP only if finished and MVP exists
                 if(game.mvp_user_id) {
                     const allPlayers = [...(game.team_a || []), ...(game.team_b || [])]; // Use teams if available, else look in profiles?
                     // Fetch MVP profile for username if needed (might be slow) - simpler: find in team arrays if populated
                     const mvpPlayer = allPlayers.find(p => p.user_id === game.mvp_user_id);
                     if (mvpPlayer) {
                         mvpUsername.textContent = mvpPlayer.username || 'Unknown MVP';
                         // MVP score/stats might need separate tracking or calculation; keep simple for now
                         mvpScore.textContent = `(Awarded MVP)`;
                         showElement(mvpHighlight);
                     } else {
                        // MVP ID exists but player not found in teams (shouldn't happen often)
                        mvpUsername.textContent = 'MVP Awarded';
                        mvpScore.textContent = `(ID: ${game.mvp_user_id.substring(0,6)}...)`;
                        showElement(mvpHighlight);
                     }
                 } else {
                     hideElement(mvpHighlight);
                 }
                 showElement(shareResultsBtn); // Only show share for finished games
                 startConfetti(); // Start confetti only for finished games
             } else if (game.status === 'cancelled') {
                 title = "Game Cancelled";
                 finalScore.textContent = "This game was cancelled.";
                 showElement(finalScore);
                 hideElement(mvpHighlight);
                 hideElement(shareResultsBtn);
             }

             gameEndTitle.textContent = title;
             gameEndScreen.style.background = background;


             backToMainBtn.onclick = () => { stopConfetti(); navigateTo('main'); fetchGames(); };
             viewLeaderboardBtn.onclick = () => { stopConfetti(); navigateTo('leaderboard'); fetchLeaderboard('global'); };
             shareResultsBtn.onclick = () => {
                if (game.status === 'finished') {
                    const shareText = `HoopsLink Game Finished! ${game.location_name || 'Game'}: A(${scoreA})-B(${scoreB}). ${game.winner ? (game.winner === 'draw' ? 'Draw!' : `Team ${game.winner} wins!`) : ''}`;
                    showShareModal(shareText, window.location.href); // Maybe share a specific game result URL later
                }
             };
         };
        const renderProfile = (profileData) => {
             hideElement(profileLoader); if (!profileData) { profileContent.innerHTML = `<p class="error-text p-2 tc">Profile could not be loaded.</p>`; showElement(profileContent); return; } showElement(profileContent); if (profileContent.firstElementChild?.classList.contains('error-text')) { /* Clear error if needed, structure assumed OK */ }
             userProfile = profileData; // Update global state
             profileUsername.textContent = profileData.username || 'No Username Set'; profileEmail.textContent = currentUser?.email || 'No email found'; profileAvatar.textContent = getUserAvatarText(profileData.username);
             // Populate edit fields with current data
             editProfileUsernameInput.value = profileData.username || ''; editProfileCityInput.value = profileData.city || ''; editProfileStateInput.value = profileData.state || ''; editProfileCountryInput.value = profileData.country || '';
             // Populate stats
             profileStatPoints.textContent = profileData.total_points_scored || 0; profileStatGames.textContent = profileData.games_played || 0; profileStatMvp.textContent = profileData.mvp_awards || 0;
             toggleProfileEdit(false); // Ensure profile starts in display mode
             loadGameHistory(profileData.user_id); // Load game history after rendering profile
         };
        const renderGameHistory = (games) => {
             hideElement(gameHistoryLoader); gameHistoryList.innerHTML = ''; if (!games || games.length === 0) { showElement(noHistoryMessage); return; } hideElement(noHistoryMessage);
             // Sort by creation time (most recent first)
             games.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
             games.forEach(game => {
                 const li = document.createElement('li'); li.classList.add('history-item');
                 const isPlayerA = game.team_a?.some(p => p.user_id === currentUser?.id);
                 const isPlayerB = game.team_b?.some(p => p.user_id === currentUser?.id);
                 let result = 'N/A'; let resultClass = '';
                 if (game.winner === 'A' && isPlayerA) { result = 'Win'; resultClass = 'result-win'; }
                 else if (game.winner === 'B' && isPlayerB) { result = 'Win'; resultClass = 'result-win'; }
                 else if (game.winner === 'A' && isPlayerB) { result = 'Loss'; resultClass = 'result-loss'; }
                 else if (game.winner === 'B' && isPlayerA) { result = 'Loss'; resultClass = 'result-loss'; }
                 else if (game.winner === 'draw' && (isPlayerA || isPlayerB)) { result = 'Draw'; }
                 else if (!isPlayerA && !isPlayerB) { result = 'N/A (Spectator?)'; } // Should ideally not happen if query is correct

                 const isMvp = game.mvp_user_id === currentUser?.id;
                 li.innerHTML = `<div class="history-details">${game.location_name || 'Game'} - ${formatDate(game.created_at)}</div><div class="history-score">Score: ${game.score_a || 0} - ${game.score_b || 0}</div><div class="history-result ${resultClass}">Result: ${result} ${isMvp ? '(🏆 MVP)' : ''}</div>`;
                 gameHistoryList.appendChild(li);
             });
         };
        const renderLeaderboard = (players) => {
             hideElement(leaderboardLoader); leaderboardList.innerHTML = ''; if (!players || players.length === 0) { showElement(noLeaderboardMessage); return; } hideElement(noLeaderboardMessage);
             players.forEach((player, index) => {
                 const li = document.createElement('li'); li.classList.add('leaderboard-item'); li.style.setProperty('--animation-order', index);
                 // Basic stats display
                 li.innerHTML = `<span class="leaderboard-rank">${index + 1}</span><div class="leaderboard-avatar">${getUserAvatarText(player.username)}</div><div class="leaderboard-info"><div class="leaderboard-username">${player.username || 'Anonymous User'}</div><div class="leaderboard-stat">🏆 ${player.mvp_awards || 0} MVPs | ${player.games_played || 0} Games</div></div><div class="leaderboard-score">${player.total_points_scored || 0} PTS</div>`;
                 leaderboardList.appendChild(li);
             });
             requestAnimationFrame(() => { document.querySelectorAll('.leaderboard-item').forEach(item => { item.style.opacity = '1'; item.style.transform = 'translateY(0)'; }); });
         };
        const renderChatMessages = (messages) => {
             if (!chatMessages) return; // Guard against element not existing yet
             if (!messages || !Array.isArray(messages)) { messages = []; }
             // Check if user is near the bottom before adding messages
             const shouldScroll = chatMessages.scrollTop + chatMessages.clientHeight >= chatMessages.scrollHeight - 50;
             chatMessages.innerHTML = ''; // Clear existing messages
             messages.forEach(msg => {
                 const div = document.createElement('div'); div.classList.add('chat-message');
                 const isOwn = msg.user_id === currentUser?.id;
                 if (isOwn) div.classList.add('own');
                 // Sanitize message content slightly (basic example)
                 const safeMessage = msg.message ? msg.message.replace(/</g, "&lt;").replace(/>/g, "&gt;") : '';
                 div.innerHTML = `<div class="message-bubble">${safeMessage}</div><div class="message-meta">${!isOwn ? `<span class="message-sender">${msg.username || 'User'}</span>` : ''}<span>${formatDate(msg.timestamp || new Date())}</span></div>`;
                 chatMessages.appendChild(div);
             });
             // Scroll to bottom if user was near the bottom or chat just opened
             if (shouldScroll || chatDrawer.classList.contains('open')) {
                 scrollToChatBottom();
             }
         };


        // --- DATA FETCHING AND UPDATING ---
        const fetchGames = async () => {
            if (!supabase) return;
            showElement(gameListLoader); hideElement(noGamesMessage); gameList.innerHTML = '';
            try {
                // Fetch pending and active games
                const { data, error } = await supabase.from('games')
                    .select('*')
                    .in('status', ['pending', 'active'])
                    .order('start_time', { ascending: true, nullsLast: true }); // Order by time

                if (error) throw error;
                renderGameList(data);
                subscribeToGamesList(); // Subscribe after initial fetch
            } catch (error) {
                console.error('Fetch games error:', error);
                hideElement(gameListLoader);
                showElement(noGamesMessage);
                noGamesMessage.textContent = "Failed to load games.";
            }
        };
        const fetchGameDetails = async (gameId) => {
            if (!supabase || !gameId) return;
            showElement(gameDetailLoader); hideElement(gameDetailContent); hideElement(gameDetailError);
            try {
                const { data, error, status } = await supabase.from('games')
                    .select('*') // Select all columns for detail view
                    .eq('id', gameId)
                    .single();

                if (error) {
                    if (status === 406) { // Not found
                         throw new Error("Game not found or has been removed.");
                    } else { // Other DB error
                        throw error;
                    }
                }

                // If game is active or finished/cancelled, redirect from detail view
                if (data.status === 'active') {
                    console.log(`Game ${gameId} is active, navigating to active screen.`);
                    navigateTo('active');
                    renderActiveGame(data); // Render immediately
                    subscribeToGame(gameId); // Subscribe for updates
                } else if (data.status === 'finished' || data.status === 'cancelled') {
                     console.log(`Game ${gameId} is ${data.status}, navigating to end screen.`);
                     navigateTo('end');
                     renderGameEnd(data); // Render end screen
                     // No need to subscribe to finished/cancelled games
                } else if (data.status === 'pending') {
                    // Stay on detail screen for pending games
                    renderGameDetail(data);
                    subscribeToGame(gameId); // Subscribe for updates (joins, cancellations, start)
                    renderChatMessages(data.chat_log || []); // Show chat log
                } else {
                    // Unknown status? Treat as error or navigate away
                    console.warn(`Game ${gameId} has unexpected status: ${data.status}`);
                    navigateTo('main');
                    fetchGames();
                }

            } catch (error) {
                console.error('Fetch game details error:', error);
                hideElement(gameDetailLoader);
                showElement(gameDetailError);
                gameDetailError.textContent = `Error loading game: ${error.message}.`;
                hideElement(gameDetailContent);
                // Maybe add a button to go back to the list
            }
        };
        const createGame = async (location, dateTime) => {
            if (!supabase || !currentUser) return { error: { message: 'You must be logged in to create a game.'}};
            try {
                if (!location.trim()) return { error: { message: 'Please provide a location name.' } };
                if (!dateTime) return { error: { message: 'Please select a date and time.' } };
                // Ensure user has a profile/username before creating
                if (!userProfile?.username) {
                    userProfile = await getUserProfile(currentUser.id); // Attempt to fetch if missing
                    if (!userProfile?.username) {
                        return { error: { message: 'Please set a username in your profile before creating a game.' } };
                    }
                }
                // Creator automatically joins the game
                const initialPlayer = { user_id: currentUser.id, username: userProfile.username };
                const initialChatMessage = {
                    user_id: 'system', // Use 'system' or null for system messages
                    username: 'System',
                    message: `${userProfile.username} created the game! Waiting for players...`,
                    timestamp: new Date().toISOString()
                };
                const { data, error } = await supabase.from('games')
                    .insert({
                        creator_id: currentUser.id,
                        location_name: location.trim(),
                        start_time: dateTime,
                        status: 'pending', // Initial status
                        players: [initialPlayer], // Add creator to players list
                        chat_log: [initialChatMessage], // Start chat log
                        // Ensure other fields like teams, scores, etc., are null or default initially
                        team_a: null,
                        team_b: null,
                        score_a: 0,
                        score_b: 0,
                        point_proposals: null,
                        winner: null,
                        mvp_user_id: null,
                        game_end_time: null // Null initially, set when game starts
                    })
                    .select() // Select the newly created game data
                    .single(); // Expecting a single row back

                if (error) throw error;
                return { data, error: null }; // Success
            } catch (error) {
                console.error('Create game error:', error);
                return { error }; // Return the error object
            }
        };
        const joinGame = async (gameId) => {
            if (!supabase || !currentUser || !currentGameData || currentGameData.status !== 'pending') {
                gameDetailError.textContent = 'Cannot join this game now.'; showElement(gameDetailError); return;
            }
            disableElement(joinLeaveGameBtn); gameDetailError.textContent = '';
            try {
                const currentProfile = userProfile || await getUserProfile(currentUser.id); // Use cached or fetch
                if (!currentProfile?.username) throw new Error('Please set a username in your profile first.');

                let { players, chat_log } = currentGameData; // Get current players and chat
                players = players || [];
                chat_log = chat_log || [];

                if (players.length >= 10) throw new Error('This game is already full.');
                if (players.some(p => p.user_id === currentUser.id)) { // Already in game
                    enableElement(joinLeaveGameBtn); updateGameDetailButtons(currentGameData); return; // Just re-enable button
                }

                const newPlayer = { user_id: currentUser.id, username: currentProfile.username };
                const updatedPlayers = [...players, newPlayer];
                const joinMessage = { user_id: 'system', username: 'System', message: `${currentProfile.username} joined the game!`, timestamp: new Date().toISOString() };
                const updatedChatLog = [...chat_log, joinMessage];

                // Update the game in DB
                const { error } = await supabase.from('games')
                    .update({ players: updatedPlayers, chat_log: updatedChatLog })
                    .eq('id', gameId)
                    .eq('status', 'pending'); // Ensure game is still pending

                if (error) throw error;
                // No need to manually update UI, realtime subscription will handle it.
                // Enable button might happen via realtime update render, or do it here defensively?
                // Let's rely on realtime for consistency. If it fails, user sees old state briefly.

            } catch (error) {
                console.error('Join game error:', error);
                gameDetailError.textContent = `Failed to join: ${error.message}`;
                showElement(gameDetailError);
                // Re-enable button based on potentially stale data if DB update failed
                 enableElement(joinLeaveGameBtn);
                 updateGameDetailButtons(currentGameData); // Re-render buttons based on potentially old data
            }
        };
        const leaveGame = async (gameId) => {
            if (!supabase || !currentUser || !currentGameData || currentGameData.status !== 'pending') {
                 gameDetailError.textContent = 'Cannot leave this game now.'; showElement(gameDetailError); return;
            }
            // Prevent creator from leaving via this button (must cancel)
            if (currentGameData.creator_id === currentUser.id) {
                 gameDetailError.textContent = 'Creator cannot leave, please cancel the game instead.'; showElement(gameDetailError); return;
            }

            disableElement(joinLeaveGameBtn); gameDetailError.textContent = '';
            try {
                let { players, chat_log } = currentGameData;
                players = players || [];
                chat_log = chat_log || [];

                if (!players.some(p => p.user_id === currentUser.id)) { // Not actually in game
                     enableElement(joinLeaveGameBtn); updateGameDetailButtons(currentGameData); return; // Just re-enable button
                }

                const updatedPlayers = players.filter(p => p.user_id !== currentUser.id);
                const currentProfile = userProfile || await getUserProfile(currentUser.id); // For username in message
                const username = currentProfile?.username || 'A player';
                const leaveMessage = { user_id: 'system', username: 'System', message: `${username} left the game.`, timestamp: new Date().toISOString() };
                const updatedChatLog = [...chat_log, leaveMessage];

                // Update the game in DB
                const { error } = await supabase.from('games')
                    .update({ players: updatedPlayers, chat_log: updatedChatLog })
                    .eq('id', gameId)
                    .eq('status', 'pending');

                if (error) throw error;
                // Realtime will update UI

            } catch (error) {
                console.error('Leave game error:', error);
                gameDetailError.textContent = `Failed to leave: ${error.message}`;
                showElement(gameDetailError);
                // Re-enable button based on potentially stale data
                enableElement(joinLeaveGameBtn);
                updateGameDetailButtons(currentGameData);
            }
        };
        const cancelGame = async (gameId) => {
            if (!supabase || !currentUser || !currentGameData || currentGameData.status !== 'pending') {
                gameDetailError.textContent = "Can only cancel pending games."; showElement(gameDetailError); return;
            }
            if (currentGameData.creator_id !== currentUser.id) {
                gameDetailError.textContent = "Only the creator can cancel the game."; showElement(gameDetailError); return;
            }

            disableElement(cancelGameBtn); disableElement(beginGameBtn); disableElement(joinLeaveGameBtn); // Disable all actions
            gameDetailError.textContent = '';

            if (!confirm("Are you sure you want to cancel this game? This cannot be undone.")) {
                // Re-enable buttons based on current state if user cancels confirmation
                updateGameDetailButtons(currentGameData);
                return;
            }

            try {
                const cancelMessage = { user_id: 'system', username: 'System', message: `Game cancelled by the creator.`, timestamp: new Date().toISOString() };
                const updatedChatLog = [...(currentGameData.chat_log || []), cancelMessage];

                const { error } = await supabase.from('games')
                    .update({ status: 'cancelled', players: null, chat_log: updatedChatLog }) // Clear players list on cancel
                    .eq('id', gameId)
                    .eq('status', 'pending'); // Ensure it's still pending

                if (error) throw error;
                // Realtime should navigate user away or show cancelled state.
                // If realtime fails, user might be stuck. Navigate defensively?
                // Let's assume realtime works. It will trigger fetchGameDetails -> navigateTo('end') -> renderGameEnd.

            } catch (error) {
                console.error('Cancel game error:', error);
                gameDetailError.textContent = `Failed to cancel: ${error.message}`;
                showElement(gameDetailError);
                // Re-enable buttons based on potentially stale data
                updateGameDetailButtons(currentGameData);
            }
        };
        const beginGame = async (gameId) => {
            if (!supabase || !currentUser || !currentGameData || currentGameData.status !== 'pending') {
                 gameDetailError.textContent = "Game cannot be started now."; showElement(gameDetailError); return;
            }
            if (currentGameData.creator_id !== currentUser.id) {
                 gameDetailError.textContent = "Only the creator can start the game."; showElement(gameDetailError); return;
            }
             const players = currentGameData.players || [];
            if (players.length < MIN_PLAYERS_TO_START) {
                 gameDetailError.textContent = `Cannot start yet, need at least ${MIN_PLAYERS_TO_START} players (currently ${players.length}).`; showElement(gameDetailError); return;
            }

            disableElement(beginGameBtn); disableElement(cancelGameBtn); disableElement(joinLeaveGameBtn);
            gameDetailError.textContent = '';

            try {
                // 1. Shuffle Players (Fisher-Yates algorithm)
                let shuffledPlayers = [...players];
                for (let i = shuffledPlayers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledPlayers[i], shuffledPlayers[j]] = [shuffledPlayers[j], shuffledPlayers[i]];
                }

                // 2. Assign Teams
                const midPoint = Math.ceil(shuffledPlayers.length / 2);
                const teamA = shuffledPlayers.slice(0, midPoint);
                const teamB = shuffledPlayers.slice(midPoint);

                // 3. Calculate Game End Time
                const gameEndTime = new Date(Date.now() + GAME_DURATION_MINUTES * 60 * 1000);

                // 4. Prepare Update Payload
                const startMessage = { user_id: 'system', username: 'System', message: `Game started by the creator! Teams assigned. ${GAME_DURATION_MINUTES} min clock. GLHF!`, timestamp: new Date().toISOString() };
                const updatedChatLog = [...(currentGameData.chat_log || []), startMessage];

                const updatePayload = {
                    status: 'active',
                    team_a: teamA,
                    team_b: teamB,
                    score_a: 0, // Reset scores
                    score_b: 0,
                    point_proposals: null, // Clear any old proposals
                    players: null, // Clear the 'pending players' list
                    chat_log: updatedChatLog,
                    game_end_time: gameEndTime.toISOString() // Set the calculated end time
                };

                // 5. Update Database
                const { error } = await supabase.from('games')
                    .update(updatePayload)
                    .eq('id', gameId)
                    .eq('status', 'pending'); // Ensure still pending

                if (error) throw error;

                // 6. Navigate & Render (will also be triggered by realtime, but doing it here provides faster feedback)
                // navigateTo('active'); // Let realtime handle navigation for consistency
                // renderActiveGame(await fetchGameDetails(gameId)); // Re-fetch might be needed if realtime is slow

                // Realtime subscription should now pick up the 'active' status change and handle navigation/rendering.

            } catch (error) {
                console.error('Begin game error:', error);
                gameDetailError.textContent = `Failed to start game: ${error.message}`;
                showElement(gameDetailError);
                // Re-enable buttons based on potentially stale data
                updateGameDetailButtons(currentGameData);
            }
        };

        // --- Collaborative Scoring Logic ---
        const proposeScore = async(team) => { // team is 'A' or 'B'
            if(!supabase || !currentUser || !currentGameData || currentGameData.status !== 'active' || confirmingScore) {
                 setScoreErrorMessage("Cannot propose score now."); return;
            }
            const proposalKey = team === 'A' ? 'teamA' : 'teamB';
            const currentProposals = currentGameData.point_proposals || {};

            // Check if another proposal is active for the *other* team
            const otherKey = team === 'A' ? 'teamB' : 'teamA';
            if (currentProposals[otherKey]) {
                 setScoreErrorMessage("Wait for the other team's proposal to resolve."); return;
            }

            // Check if this user already proposed or confirmed *this* proposal
            const existingProposal = currentProposals[proposalKey];
            if (existingProposal) {
                if (existingProposal.proposedBy === currentUser.id) {
                    setScoreErrorMessage("You already proposed this."); return;
                }
                if (existingProposal.confirmedBy?.includes(currentUser.id)) {
                     setScoreErrorMessage("You already confirmed this."); return;
                }
            }

            console.log(`User ${currentUser.id} proposing +1 for Team ${team}`);
            setScoreProposalMessage(`Proposing +1 Team ${team}...`); hideElement(scoreErrorMessage);

            // Create or update the proposal
            const newProposalData = {
                 proposedBy: existingProposal?.proposedBy || currentUser.id, // Keep original proposer if exists
                 confirmedBy: [...(existingProposal?.confirmedBy || []), currentUser.id] // Add current user to confirmations
             };
            // Ensure proposal includes the proposer in confirmedBy list if it's the first confirmation
             if (!existingProposal) {
                 newProposalData.confirmedBy = [currentUser.id];
                 newProposalData.proposedBy = currentUser.id; // Ensure proposer is set
             }


             const updatePayload = {
                 point_proposals: {
                     ...currentProposals, // Keep other existing proposals if any (shouldn't be)
                     [proposalKey]: newProposalData
                 }
             };

             try {
                 const { error } = await supabase.from('games')
                    .update(updatePayload)
                    .eq('id', currentGameId)
                    .eq('status', 'active'); // Ensure game is still active
                 if (error) throw error;
                 // Realtime update will trigger checkAndApplyScore and UI updates

             } catch(e) {
                 console.error("Propose score error:", e);
                 setScoreErrorMessage("Failed to propose score."); hideElement(scoreProposalMessage);
             }
        };
        const confirmScoreProposal = async() => {
            if(!supabase || !currentUser || !currentGameData || !currentScoreProposal || confirmingScore || currentGameData.status !== 'active') {
                resetScoreConfirmationUI(); return;
            }

            const proposalKey = currentScoreProposal.team === 'A' ? 'teamA' : 'teamB';
            const currentProposals = currentGameData.point_proposals || {};
            const proposalToConfirm = currentProposals[proposalKey];

            // Basic sanity checks
            if (!proposalToConfirm) { resetScoreConfirmationUI(); return; } // Proposal disappeared
            if (proposalToConfirm.proposedBy === currentUser.id && proposalToConfirm.confirmedBy?.length < 1) {
                setScoreErrorMessage("Cannot confirm your own initial proposal."); // Prevent proposer from being the only confirmation instantly
                resetScoreConfirmationUI(); return;
            }
            if (proposalToConfirm.confirmedBy?.includes(currentUser.id)) { // Already confirmed
                 resetScoreConfirmationUI(); return;
            }

            confirmingScore = true; // Prevent double clicks
            disableElement(confirmScoreBtn); disableElement(rejectScoreBtn);

            const updatedConfirmedBy = [...(proposalToConfirm.confirmedBy || []), currentUser.id];
            const updatedProposal = { ...proposalToConfirm, confirmedBy: updatedConfirmedBy };
            const updatePayload = { point_proposals: { ...currentProposals, [proposalKey]: updatedProposal } };

            try {
                 const { error } = await supabase.from('games')
                    .update(updatePayload)
                    .eq('id', currentGameId)
                    .eq('status', 'active');
                 if (error) throw error;
                 // Realtime update will handle UI and checkAndApplyScore
                 resetScoreConfirmationUI(); // Reset UI immediately for responsiveness

            } catch(e) {
                 console.error("Confirm score error:", e);
                 setScoreErrorMessage("Failed to confirm score.");
                 resetScoreConfirmationUI(); // Reset UI on error
            } finally {
                 // Add a small delay before allowing another action
                 setTimeout(() => { confirmingScore = false; }, 300);
            }
        };
        const rejectScoreProposal = async() => {
            if(!supabase || !currentUser || !currentGameData || !currentScoreProposal || confirmingScore || currentGameData.status !== 'active') {
                 resetScoreConfirmationUI(); return;
            }

            console.log(`User ${currentUser.id} rejecting proposal for Team ${currentScoreProposal.team}`);
            confirmingScore = true; // Prevent actions during rejection
            disableElement(confirmScoreBtn); disableElement(rejectScoreBtn);

            const proposalKey = currentScoreProposal.team === 'A' ? 'teamA' : 'teamB';
            let currentProposals = { ...(currentGameData.point_proposals || {}) }; // Clone proposals

            if(currentProposals[proposalKey]) {
                delete currentProposals[proposalKey]; // Remove the rejected proposal
                const updatePayload = { point_proposals: Object.keys(currentProposals).length > 0 ? currentProposals : null }; // Set to null if empty

                try {
                    const { error } = await supabase.from('games')
                        .update(updatePayload)
                        .eq('id', currentGameId)
                        .eq('status', 'active');
                    if (error) throw error;
                    // Realtime update will refresh UI
                    setScoreProposalMessage("Proposal rejected."); // Give feedback
                    setTimeout(()=>hideElement(scoreProposalMessage), 3000);

                } catch(e) {
                     console.error("Reject score DB error:", e);
                     setScoreErrorMessage("Failed to reject proposal.");
                }
            }
            // Reset UI regardless of DB success/failure
             resetScoreConfirmationUI();
             setTimeout(() => { confirmingScore = false; }, 300); // Re-enable actions after delay
        };
        // This function checks if any proposal has enough confirmations and applies the score
        const checkAndApplyScore = async(gameData) => {
            if(!gameData || gameData.status !== 'active' || !gameData.point_proposals) {
                updateScoreProposalUI(gameData?.point_proposals); // Still update UI even if no proposals
                return;
            }

            const proposals = gameData.point_proposals;
            const totalPlayers = (gameData.team_a?.length || 0) + (gameData.team_b?.length || 0);
            if (totalPlayers < 1) return; // Avoid division by zero or weird logic

            // Determine required confirmations (e.g., majority)
            // Simple majority: Math.floor(totalPlayers / 2) + 1
            // Stricter: Math.ceil(totalPlayers / 2) + (totalPlayers % 2 === 0 ? 1 : 0) // Need > 50%
            const requiredConfirmations = Math.max(1, Math.floor(totalPlayers / 2) + 1); // At least 1, simple majority

            let scoreApplied = false;
            let updatePayload = {};

            for (const key in proposals) { // key is 'teamA' or 'teamB'
                const proposal = proposals[key];
                if (proposal?.confirmedBy?.length >= requiredConfirmations) {
                    const teamToScore = key === 'teamA' ? 'A' : 'B';
                    console.log(`Score confirmed for Team ${teamToScore}! (${proposal.confirmedBy.length}/${requiredConfirmations})`);

                    // Prepare update: increment score and clear proposals
                    updatePayload = {
                        point_proposals: null, // Clear all proposals once one is confirmed
                        score_a: gameData.score_a || 0,
                        score_b: gameData.score_b || 0
                    };
                    if (teamToScore === 'A') {
                        updatePayload.score_a++;
                    } else {
                         updatePayload.score_b++;
                    }
                    scoreApplied = true;
                    break; // Only apply one score per check
                }
            }

            if (scoreApplied) {
                hideElement(scoreProposalMessage); hideElement(scoreErrorMessage); resetScoreConfirmationUI();
                try {
                    // Update the database with the new score and cleared proposals
                    const { data: updatedGame, error } = await supabase.from('games')
                        .update(updatePayload)
                        .eq('id', gameData.id)
                        .eq('status', 'active') // Ensure still active
                        .select() // Get the updated game data back
                        .single();

                    if (error) throw error;
                    console.log("Score applied successfully. New score:", updatedGame.score_a, "-", updatedGame.score_b);
                    currentGameData = updatedGame; // Update local state immediately

                    // Check if the game should end due to score limit AFTER applying score
                    if ((updatedGame.score_a >= SCORE_LIMIT || updatedGame.score_b >= SCORE_LIMIT) && updatedGame.score_a !== updatedGame.score_b) {
                        console.log("Score limit reached, ending game.");
                        endGame(updatedGame); // End the game
                    } else {
                         renderActiveGame(updatedGame); // Re-render active game with new score (if not ended)
                    }

                } catch(e) {
                     console.error("Apply score error:", e);
                     setScoreErrorMessage("Failed to apply score update.");
                     // Re-render with old data maybe? Or let next realtime update try again.
                     renderActiveGame(gameData); // Re-render with data before failed apply
                }
            } else {
                // No score applied, just update the proposal UI based on current proposals
                updateScoreProposalUI(proposals);
            }
        };
        const updateScoreProposalUI = (proposals) => {
            resetScoreConfirmationUI(); // Hide confirmation modal by default
            hideElement(scoreProposalMessage); // Hide general proposal message
            hideElement(scoreErrorMessage); // Hide error message

            proposals = proposals || {};
            let activeProposal = null;
            let activeProposalKey = null;

            // Find the first active proposal (should only be one ideally)
            for (const key in proposals) {
                if (proposals[key]) {
                    activeProposal = proposals[key];
                    activeProposalKey = key;
                    break;
                }
            }

            if (activeProposal && currentUser) {
                const team = activeProposalKey === 'teamA' ? 'A' : 'B';
                const proposerId = activeProposal.proposedBy;
                const confirmedByIds = activeProposal.confirmedBy || [];
                const totalPlayers = (currentGameData?.team_a?.length || 0) + (currentGameData?.team_b?.length || 0);
                const requiredConfirmations = Math.max(1, Math.floor(totalPlayers / 2) + 1);

                // If current user has NOT confirmed yet, show the confirmation modal
                if (!confirmedByIds.includes(currentUser.id)) {
                    currentScoreProposal = { proposedBy: proposerId, team: team }; // Set state for confirm/reject handlers
                    scoreConfirmText.textContent = `Confirm +1 Team ${team}? (${confirmedByIds.length}/${requiredConfirmations})`;
                    showScoreConfirmationModal();
                } else {
                    // User has already confirmed, show waiting message
                    setScoreProposalMessage(`Waiting for others... (${confirmedByIds.length}/${requiredConfirmations} confirmed for Team ${team})`);
                }
            }
            // If no active proposal, all messages/modals remain hidden
        };
        const showScoreConfirmationModal = () => { scoreConfirmationModal.classList.add('visible'); enableElement(confirmScoreBtn); enableElement(rejectScoreBtn); };
        const resetScoreConfirmationUI = () => { scoreConfirmationModal.classList.remove('visible'); currentScoreProposal = null; };
        const setScoreProposalMessage = (msg) => { scoreProposalMessage.textContent = msg; showElement(scoreProposalMessage); hideElement(scoreErrorMessage); };
        const setScoreErrorMessage = (msg) => { scoreErrorMessage.textContent = msg; showElement(scoreErrorMessage); hideElement(scoreProposalMessage); setTimeout(()=>hideElement(scoreErrorMessage), 5000); }; // Auto-hide error after 5s

        const endGame = async (gameData) => {
            // Prevent multiple endGame calls for the same game
            if (!gameData || !['active', 'pending'].includes(gameData.status)) { // Allow ending pending games if time expires somehow? No, only active.
                 console.warn("endGame called on non-active or missing game data. Status:", gameData?.status);
                 return;
            }
             // Check if already finishing (maybe via race condition)
            if (gameData.status !== 'active') {
                console.log("Game already finished or cancelled. Skipping endGame.");
                return;
            }

            console.log("Attempting to end game:", gameData.id);
            stopGameTimer(); // Ensure timer is stopped

            const scoreA = Number(gameData.score_a || 0);
            const scoreB = Number(gameData.score_b || 0);
            let winner = 'draw'; // Default to draw
             if (scoreA > scoreB) winner = 'A';
             else if (scoreB > scoreA) winner = 'B';

             // Determine MVP - simplistic: random player from winning team, or creator if draw/no teams?
             // Better MVP: Could be highest scorer if tracked, or most confirmations? Keep simple for now.
             let mvpUserId = null;
             const winningTeam = winner === 'A' ? gameData.team_a : (winner === 'B' ? gameData.team_b : null);
             if (winningTeam && winningTeam.length > 0) {
                 // Pick a random player from the winning team as MVP
                 mvpUserId = winningTeam[Math.floor(Math.random() * winningTeam.length)].user_id;
             } else if (winner === 'draw') {
                // Assign MVP to creator on draw? Or no MVP? Let's say no MVP on draw.
                // mvpUserId = gameData.creator_id;
             }
            // If somehow teams are empty but there's a winner by score? Assign to creator? Fallback.
             if (!mvpUserId && winner !== 'draw') {
                const teamWithScore = winner === 'A' ? gameData.team_a : gameData.team_b;
                if (!teamWithScore || teamWithScore.length === 0) {
                     mvpUserId = gameData.creator_id; // Fallback MVP if winning team empty
                }
             }


            const updatePayload = {
                 status: 'finished',
                 winner: winner,
                 mvp_user_id: mvpUserId,
                 point_proposals: null, // Clear proposals
                 game_end_time: gameData.game_end_time || new Date().toISOString() // Keep original end time if set, else now
                 // Keep scores, teams, location etc.
             };

            try {
                 // Update the game status to 'finished' first
                 // Use .eq('status', 'active') to prevent race conditions if already finished/cancelled
                 const { error: gameUpdateError } = await supabase.from('games')
                     .update(updatePayload)
                     .eq('id', gameData.id)
                     .eq('status', 'active'); // *** Crucial check ***

                 if (gameUpdateError) {
                     // If the error indicates the row was not found (likely because status was already changed), log it but don't throw hard error
                     if (gameUpdateError.code === 'PGRST116' || gameUpdateError.details?.includes("violates row-level security policy")) { // Needs RLS check potentially
                          console.warn(`Game ${gameData.id} likely already finished/cancelled by another client. Error:`, gameUpdateError.message);
                          // Fetch latest game state to navigate correctly
                          const { data: latestGameData } = await supabase.from('games').select('*').eq('id', gameData.id).single();
                          if (latestGameData && latestGameData.status === 'finished') {
                              navigateTo('end');
                              renderGameEnd(latestGameData);
                          } else {
                             navigateTo('main'); // Fallback
                             fetchGames();
                          }
                          return; // Stop further processing
                     } else {
                         throw gameUpdateError; // Throw other DB errors
                     }
                 }

                 console.log(`Game ${gameData.id} status updated to finished.`);

                 // Update player stats asynchronously (don't block UI)
                 const playersToUpdate = [...(gameData.team_a || []), ...(gameData.team_b || [])];
                 if (playersToUpdate.length > 0) {
                     updatePlayerStats(playersToUpdate, mvpUserId); // Fire-and-forget style
                 } else {
                    console.warn("No players found in teams for stat updates.");
                 }

                // Navigation to end screen should happen via realtime subscription update for consistency.
                // The subscription will see the status change to 'finished'.

            } catch (error) {
                 console.error("End game process error:", error);
                 // Try to show an error on the active screen if still there
                 if (currentScreen === 'active') {
                     setScoreErrorMessage("Error finalizing game. Please check game list.");
                 }
                 // Consider navigating back to main list as a fallback
                 // navigateTo('main'); fetchGames();
            }
        };

        // Helper function to update stats (run async, no waiting)
        const updatePlayerStats = async (players, mvpUserId) => {
            console.log("Updating stats for players:", players.map(p => p.username));
            const statPromises = players.map(async (player) => {
                 try {
                     // Fetch the player's current profile for stats
                     // Use SELECT with specific columns for efficiency
                     const { data: profile, error: fetchError } = await supabase
                         .from('profiles')
                         .select('games_played, total_points_scored, mvp_awards')
                         .eq('user_id', player.user_id)
                         .single();

                     if (fetchError && fetchError.code !== 'PGRST116') { // Ignore 'not found' error here, just log
                        console.warn(`Could not fetch profile for stat update (User ID: ${player.user_id}):`, fetchError.message);
                        return; // Skip update if profile fetch fails badly
                     }
                     if (!profile) {
                         console.warn(`Profile not found for stat update (User ID: ${player.user_id}). Skipping.`);
                         return; // Skip update if profile doesn't exist
                     }


                     // Calculate updates
                     const isMvp = player.user_id === mvpUserId;
                     const updates = {
                         games_played: (profile.games_played || 0) + 1,
                         // Basic points: +5 for playing, +10 bonus for MVP
                         total_points_scored: (profile.total_points_scored || 0) + 5 + (isMvp ? 10 : 0),
                         mvp_awards: (profile.mvp_awards || 0) + (isMvp ? 1 : 0)
                     };

                     // Perform the update
                     const { error: updateError } = await supabase
                        .from('profiles')
                        .update(updates)
                        .eq('user_id', player.user_id);

                     if (updateError) {
                         console.error(`Failed to update stats for ${player.username || player.user_id}:`, updateError.message);
                     } else {
                        // console.log(`Stats updated for ${player.username || player.user_id}`); // Less verbose
                     }
                 } catch(statErr) {
                     console.error(`Exception during stat update for ${player.username || player.user_id}:`, statErr);
                 }
            });

            try {
                await Promise.all(statPromises);
                console.log("Finished attempting player stat updates.");
            } catch (e) {
                console.error("Error occurred during Promise.all for stat updates:", e);
            }
        };

        const sendChatMessage = async (msg) => {
            if (!supabase || !currentUser || !currentGameData || !msg.trim()) return;
            // Ensure message can only be sent in pending or active games
            if (!['pending', 'active'].includes(currentGameData.status)) {
                alert("Chat is only available for pending or active games.");
                return;
            }
            // Ensure user profile and username are available
            if (!userProfile?.username) {
                userProfile = await getUserProfile(currentUser.id);
                if (!userProfile?.username) {
                    alert("Please set a username in your profile to send chat messages.");
                    return;
                }
            }

            const newMsg = {
                user_id: currentUser.id,
                username: userProfile.username,
                message: msg.trim(), // Use trimmed message
                timestamp: new Date().toISOString()
            };

            // Optimistic UI update: Add message locally first
            const currentLog = currentGameData.chat_log || [];
            const updatedLog = [...currentLog, newMsg];
            renderChatMessages(updatedLog); // Render the optimistic update
            scrollToChatBottom(); // Scroll down
            chatInput.value = ''; // Clear input field

            // Attempt to update the database
            try {
                const { error } = await supabase.from('games')
                    .update({ chat_log: updatedLog })
                    .eq('id', currentGameId);

                if (error) {
                    // Rollback optimistic update on error? More complex.
                    // For now, just log error and maybe show an alert.
                    console.error("Chat send error:", error);
                    alert("Failed to send message. Please try again.");
                    // Restore input field content?
                    chatInput.value = msg;
                    // Re-render with previous log to remove optimistic message?
                    renderChatMessages(currentLog);
                    // Need to decide on rollback strategy. Simple alert is easiest.
                } else {
                    // Update local game data if DB update succeeds (though realtime should also do this)
                    currentGameData.chat_log = updatedLog;
                }
            } catch (e) {
                 console.error("Chat send exception:", e);
                 alert("An error occurred while sending the message.");
                 chatInput.value = msg; // Restore input
                 renderChatMessages(currentLog); // Restore previous chat log
            }
        };
        const fetchProfileData = async (userId) => {
            if (!supabase) return;
            showElement(profileLoader); hideElement(profileContent);
            try {
                 const profile = await getUserProfile(userId);
                 if (profile) {
                     renderProfile(profile);
                 } else {
                     // Handle case where profile is null (user exists but no profile row)
                     console.warn(`Profile data not found for user ${userId}. Displaying basic info.`);
                     // Render a minimal profile or error state
                     profileContent.innerHTML = `<p class="p-2 text-center">Profile not fully set up. Email: ${currentUser?.email || 'N/A'}</p><p class="p-2 text-center"><button id="setup-profile-btn" class="btn-primary">Set Up Profile</button></p>`;
                     showElement(profileContent);
                     hideElement(profileLoader);
                     // Add event listener for setup button if needed
                 }
            } catch (e) {
                 console.error("Profile load error:", e);
                 hideElement(profileLoader);
                 profileContent.innerHTML = `<p class="error-text p-2 text-center">Failed to load profile: ${e.message}</p>`;
                 showElement(profileContent);
            }
        };
        const loadGameHistory = async (userId) => {
            if (!supabase || !userId) return;
            showElement(gameHistoryLoader); hideElement(noHistoryMessage); gameHistoryList.innerHTML = '';
            try {
                // Fetch games where status is finished and the user was in team_a OR team_b
                // This requires checking array containment, which can be done with `cs` (contains) or `or` filter
                const { data, error } = await supabase
                    .from('games')
                    .select('*')
                    .eq('status', 'finished')
                    // Filter where team_a contains user OR team_b contains user
                    // Note: Supabase JS v2 doesn't have direct JSON array contains query support like SQL.
                    // We might have to fetch more games and filter client-side, or use an RPC function.
                    // Let's fetch recent finished games and filter client-side for simplicity.
                    .order('created_at', { ascending: false })
                    .limit(50); // Limit the number of games fetched

                if (error) throw error;

                // Filter client-side
                const userHistory = data.filter(game =>
                    game.team_a?.some(player => player.user_id === userId) ||
                    game.team_b?.some(player => player.user_id === userId)
                );

                renderGameHistory(userHistory);
            } catch (e) {
                 console.error("Load game history error:", e);
                 hideElement(gameHistoryLoader);
                 showElement(noHistoryMessage);
                 noHistoryMessage.textContent = "Failed to load game history.";
            }
        };

        // Updated fetchLeaderboard
        const fetchLeaderboard = async (scope = 'global') => {
             if (!supabase) return;
             leaderboardScope = scope; // Update state
             showElement(leaderboardLoader); hideElement(noLeaderboardMessage); leaderboardList.innerHTML = '';

             let statusText = 'Showing Global Leaders (Top 50 by Points)';
             leaderboardFilterValue = null; // Reset filter value

             // Prepare query based on scope
             let query = supabase.from('profiles')
                .select('user_id, username, total_points_scored, games_played, mvp_awards, city, state, country')
                .gt('total_points_scored', 0) // Optionally filter out users with 0 points
                .order('total_points_scored', { ascending: false, nullsLast: true }) // Order by points
                .limit(50); // Limit results


             // Apply scope filters if not global
             if (scope !== 'global') {
                 // Ensure user profile is loaded for location data
                 if (!userProfile) {
                     userProfile = await getUserProfile(currentUser?.id);
                 }
                 // Check if profile exists and has necessary location fields
                 if (!userProfile) {
                     leaderboardStatus.textContent = 'Your profile is needed for local leaderboards.';
                     hideElement(leaderboardLoader); showElement(noLeaderboardMessage); noLeaderboardMessage.textContent = "Load your profile to see local leaderboards.";
                     return;
                 }

                 if (scope === 'country') {
                     if (!userProfile.country) { noLeaderboardMessage.textContent = "Set your Country in your profile to use this filter."; showElement(noLeaderboardMessage); hideElement(leaderboardLoader); return; }
                     leaderboardFilterValue = userProfile.country;
                     query = query.eq('country', leaderboardFilterValue); // Add country filter
                     statusText = `Top 50 Leaders in ${userProfile.country}`;
                 }
                 else if (scope === 'state') {
                     if (!userProfile.state || !userProfile.country) { noLeaderboardMessage.textContent = "Set your State & Country in your profile."; showElement(noLeaderboardMessage); hideElement(leaderboardLoader); return; }
                     leaderboardFilterValue = userProfile.state;
                     // Filter by both state and country for accuracy
                     query = query.eq('country', userProfile.country).eq('state', userProfile.state);
                     statusText = `Top 50 Leaders in ${userProfile.state}, ${userProfile.country}`;
                 }
                 else if (scope === 'city') {
                     if (!userProfile.city || !userProfile.state || !userProfile.country) { noLeaderboardMessage.textContent = "Set your City, State & Country in your profile."; showElement(noLeaderboardMessage); hideElement(leaderboardLoader); return; }
                     leaderboardFilterValue = userProfile.city;
                     // Filter by city, state, and country
                     query = query.eq('country', userProfile.country).eq('state', userProfile.state).eq('city', userProfile.city);
                     statusText = `Top 50 Leaders in ${userProfile.city}, ${userProfile.state}`;
                 }
             }
             leaderboardStatus.textContent = statusText; // Update status text

             try {
                 const { data, error } = await query; // Execute the prepared query
                 if (error) throw error;
                 renderLeaderboard(data);
             } catch (e) {
                 console.error(`Leaderboard fetch error (scope: ${scope}):`, e);
                 hideElement(leaderboardLoader);
                 showElement(noLeaderboardMessage);
                 noLeaderboardMessage.textContent = `Failed to load ${scope} leaderboard.`;
                 leaderboardStatus.textContent = `Error loading ${scope} leaderboard.`;
             }
         };

        // --- REALTIME SUBSCRIPTIONS ---
        const subscribeToGamesList = () => {
            if (!supabase || gamesSubscription) return; // Already subscribed
            console.log("Subscribing to Games List changes...");
            const channelName = 'public:games-list';
            gamesSubscription = supabase.channel(channelName)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'games' },
                    (payload) => {
                        console.log('Games list change detected:', payload.eventType, payload.new?.id || payload.old?.id);
                        // Re-fetch the entire list on any change for simplicity
                        // Could optimize to update/insert/delete specific item later if needed
                        if (currentScreen === 'main') {
                             console.log("Refreshing game list due to change.");
                             fetchGames(); // Re-fetch and re-render
                        }
                    }
                )
                .subscribe((status, err) => {
                    if (status === 'SUBSCRIBED') {
                        console.log(`Successfully subscribed to ${channelName}!`);
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error(`Subscription error on ${channelName}:`, status, err);
                        // REMOVED Alert: Don't show pop-up
                        // alert("Realtime connection issue with game list.");
                    } else if (status === 'CLOSED') {
                        console.log(`Subscription closed for ${channelName}.`);
                    }
                });
        };
        const unsubscribeFromGamesList = () => {
            if (gamesSubscription) {
                 console.log("Unsubscribing from Games List.");
                 supabase.removeChannel(gamesSubscription)
                    .catch(e => console.error("Error removing games list channel:", e));
                 gamesSubscription = null;
            }
        };
        const subscribeToGame = (gameId) => {
            if (!supabase || !gameId || gameSubscription) {
                // If already subscribed, ensure it's for the *correct* gameId
                if (gameSubscription && gameSubscription.channelName !== `game-${gameId}`) {
                     console.log(`Switching game subscription from ${gameSubscription.channelName} to game-${gameId}`);
                     unsubscribeFromGame(); // Unsubscribe from old game first
                } else if (gameSubscription) {
                     console.log(`Already subscribed to game-${gameId}.`);
                     return; // Already subscribed to the correct game
                } else {
                    return; // No supabase or gameId provided
                }
            }

            console.log(`Subscribing to Game ${gameId} changes...`);
            const channelName = `game-${gameId}`;
            gameSubscription = supabase.channel(channelName)
                .on('postgres_changes',
                    {
                        event: 'UPDATE', // Listen only for updates on the specific game
                        schema: 'public',
                        table: 'games',
                        filter: `id=eq.${gameId}` // Filter for this specific game ID
                    },
                    (payload) => {
                        console.log(`Game ${gameId} UPDATE received:`, payload.new.status);
                        const updatedGame = payload.new;
                        const oldGame = payload.old; // Can be useful for comparison
                        currentGameData = updatedGame; // Update global state immediately

                        // --- Handle Game State Transitions ---
                        if (currentScreen === 'detail') {
                            if (updatedGame.status === 'pending') {
                                renderGameDetail(updatedGame); // Re-render detail screen
                            } else if (updatedGame.status === 'active') {
                                console.log("Game started, navigating to active screen.");
                                navigateTo('active'); // Navigate first
                                renderActiveGame(updatedGame); // Then render
                            } else if (updatedGame.status === 'finished' || updatedGame.status === 'cancelled') {
                                console.log(`Game ${updatedGame.status}, navigating to end screen.`);
                                navigateTo('end');
                                renderGameEnd(updatedGame);
                            }
                        } else if (currentScreen === 'active') {
                            if (updatedGame.status === 'active') {
                                renderActiveGame(updatedGame); // Update active screen (scores, timer, etc.)
                                checkAndApplyScore(updatedGame); // Check if score update needs applying
                            } else if (updatedGame.status === 'finished' || updatedGame.status === 'cancelled') {
                                console.log(`Game ${updatedGame.status} while on active screen, navigating to end.`);
                                navigateTo('end');
                                renderGameEnd(updatedGame);
                            }
                        }

                        // --- Handle Chat Updates ---
                        // Compare chat logs to avoid unnecessary renders if only score changed, etc.
                         if (JSON.stringify(updatedGame.chat_log) !== JSON.stringify(oldGame?.chat_log)) {
                            if (chatDrawer.classList.contains('open') && ['detail', 'active'].includes(currentScreen)) {
                                console.log("Chat log updated, rendering messages.");
                                renderChatMessages(updatedGame.chat_log || []);
                            }
                         }
                    }
                )
                .subscribe((status, err) => {
                    if (status === 'SUBSCRIBED') {
                        console.log(`Successfully subscribed to ${channelName}!`);
                    } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
                        console.error(`Subscription error on ${channelName}:`, status, err);
                        // REMOVED Alert: Don't show pop-up
                        if (['detail', 'active'].includes(currentScreen)) {
                             // Maybe show a subtle indicator instead of alert?
                             console.warn("Realtime connection lost for current game.");
                             // Example: Show a small non-blocking message
                             // setScoreErrorMessage("Connection issue, updates may be delayed.");
                        }
                    } else if (status === 'CLOSED') {
                         console.log(`Subscription closed for ${channelName}.`);
                    }
                });
        };
        const unsubscribeFromGame = () => {
            if (gameSubscription) {
                 const channelName = gameSubscription.channelName;
                 console.log(`Unsubscribing from ${channelName}.`);
                 supabase.removeChannel(gameSubscription)
                    .catch(e => console.error(`Error removing channel ${channelName}:`, e));
                 gameSubscription = null;
            }
        };

        // --- AUTHENTICATION LOGIC ---
        const handleAuth = async (event) => {
            event.preventDefault(); if (!supabase) return;
            const isSignUp = authSubmitBtn.textContent === 'Sign Up';
            const emailValue = emailInput.value.trim();
            const passwordValue = passwordInput.value;
            const usernameValue = usernameInput.value.trim();
            authError.textContent = ''; // Clear previous errors
            disableElement(authSubmitBtn); // Prevent double submission

            let operationError = null;

            try {
                if (isSignUp) {
                    // Sign Up Logic
                    if (!usernameValue || usernameValue.length < 3) {
                        throw new Error("Username must be at least 3 characters long.");
                    }
                    if (!passwordValue || passwordValue.length < 6) {
                        // Enforce Supabase default password length
                        throw new Error("Password must be at least 6 characters long.");
                    }

                    // 1. Attempt Auth Signup
                    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
                        email: emailValue,
                        password: passwordValue,
                    });

                    if (signUpError) {
                        // Handle specific auth errors cleanly
                        if (signUpError.message.includes("User already registered")) {
                             throw new Error("An account with this email already exists. Try logging in.");
                        } else if (signUpError.message.includes("Password should be at least 6 characters")) {
                             throw new Error("Password must be at least 6 characters long.");
                        }
                        throw signUpError; // Throw other auth errors
                    }

                    // Check if user object exists (it might not if email confirmation is required by Supabase settings)
                    // For this app, we assume email confirmation is OFF or we handle login post-verification separately.
                    if (!signUpData.user) {
                        // This might happen if email verification is ON in Supabase settings.
                        // Since the request was to REMOVE the verification alert, we proceed as if successful,
                        // but profile creation might fail if the user doesn't exist yet in auth.users.
                        // Let's proceed assuming verification is off or handled implicitly.
                        console.warn("Auth signup successful, but user object might be pending verification (if enabled).");
                        // If verification IS enabled, the profile insert might fail until confirmed.
                        // For now, assume it's okay to proceed.
                    }

                    // Get the user ID (handle potential null user object)
                    const userId = signUpData.user?.id;
                    if (!userId) {
                        // This is problematic if we need the ID immediately for profile creation.
                        throw new Error("Signup succeeded but could not get user ID immediately. Please try logging in.");
                    }

                    console.log("Auth Signup successful for:", userId);

                    // 2. Attempt Profile Creation (associates username, etc.)
                    const { data: profileData, error: profileError } = await createInitialUserProfile(userId, emailValue, usernameValue);

                    if (profileError) {
                         // Inform user if profile creation failed (e.g., username taken)
                         // Potentially delete the auth user if profile fails critically? Complex rollback.
                         console.error("Profile creation failed after signup:", profileError);
                         throw new Error(`Account created, but profile setup failed: ${profileError.message}. You may need to contact support or try logging in.`);
                    }

                    // Profile created successfully
                    userProfile = profileData; // Store created profile
                    currentUser = signUpData.user; // Store the new user

                    // REMOVED Email Verification Alert
                    // alert("Signup successful! Check email for verification.");
                    alert("Signup successful! You can now log in."); // Changed alert
                    authForm.reset(); // Clear form
                    toggleAuthMode(); // Switch back to login mode

                } else {
                    // Login Logic
                    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                        email: emailValue,
                        password: passwordValue,
                    });

                    if (signInError) {
                         // Handle common login errors
                         if (signInError.message.includes("Invalid login credentials")) {
                             throw new Error("Incorrect email or password.");
                         } else if (signInError.message.includes("Email not confirmed")) {
                             // Even though verification alert removed, handle if Supabase setting is ON
                             throw new Error("Your email address hasn't been confirmed yet. Please check your inbox.");
                         }
                         throw signInError; // Throw other login errors
                    }

                    // Login successful
                    if (signInData.user) {
                         currentUser = signInData.user;
                         console.log("Login successful for:", currentUser.id);
                         // checkUserSession will fetch profile and navigate
                         await checkUserSession(); // Trigger profile load and navigation immediately
                    } else {
                         // Should not happen if error is null, but good to check
                         throw new Error("Login failed: No user data received.");
                    }
                }
            } catch (e) {
                 console.error('Authentication error:', e);
                 operationError = e; // Store error to display
            } finally {
                 // Display error message if one occurred
                 if (operationError) {
                     authError.textContent = operationError.message || 'An unknown authentication error occurred.';
                 }
                 // Re-enable button unless error requires user action (like email confirm)
                 if (!operationError || !operationError.message.includes("Email not confirmed")) {
                      enableElement(authSubmitBtn);
                 }
            }
        };
        const handleLogout = async () => {
            if (!supabase) return;
            console.log("Logging out...");
            unsubscribeFromGame(); // Clean up subscriptions
            unsubscribeFromGamesList();
            stopGameTimer(); // Stop game timer if active
            stopConfetti(); // Stop effects
            currentGameId = null; currentGameData = null;

            const { error } = await supabase.auth.signOut();
            if (error) {
                 console.error("Logout error:", error);
                 alert("Error logging out."); // Keep alert for critical errors
            } else {
                 // Clear local state
                 currentUser = null;
                 userProfile = null;
                 leaderboardScope = 'global'; // Reset leaderboard scope
                 currentScreen = 'auth'; // Set screen state before navigate
                 navigateTo('auth'); // Navigate to login screen

                 // Reset Auth Screen UI
                 authTitle.textContent = 'Login to HoopsLink';
                 authSubmitBtn.textContent = 'Login';
                 authToggleText.textContent = "Don't have an account?";
                 authToggleBtn.textContent = 'Sign Up';
                 hideElement(usernameField); // Hide username field for login
                 authForm.reset(); // Clear email/password fields
                 authError.textContent = ''; // Clear any previous auth errors
                 enableElement(authSubmitBtn); // Ensure button is enabled
                 console.log("Logged out successfully.");
            }
        };
        const toggleAuthMode = () => {
            const isCurrentlySignUp = authSubmitBtn.textContent === 'Sign Up';
            if (isCurrentlySignUp) {
                 // Switch to Login mode
                 authTitle.textContent = 'Login to HoopsLink';
                 authSubmitBtn.textContent = 'Login';
                 authToggleText.textContent = "Don't have an account?";
                 authToggleBtn.textContent = 'Sign Up';
                 hideElement(usernameField);
                 usernameInput.required = false; // Make username not required for login
            } else {
                 // Switch to Sign Up mode
                 authTitle.textContent = 'Sign Up for HoopsLink';
                 authSubmitBtn.textContent = 'Sign Up';
                 authToggleText.textContent = 'Already have an account?';
                 authToggleBtn.textContent = 'Login';
                 showElement(usernameField);
                 usernameInput.required = true; // Make username required for sign up
            }
            // Reset common elements
            authError.textContent = ''; // Clear any errors
            authForm.reset(); // Clear input fields
            enableElement(authSubmitBtn); // Ensure button is enabled
        };
                       // --- MODIFIED checkUserSession (No longer async) ---
        const checkUserSession = () => {
            console.log("checkUserSession: Starting check...");

            // *** Hide loader immediately based on currentUser state ***
            // This function assumes onAuthStateChange has already set 'currentUser' correctly.
            hideElement(screens.loading);
            console.log("checkUserSession: Loader hidden.");

            if (currentUser) {
                // User object exists (session active)
                console.log("checkUserSession: User found:", currentUser.id);

                // --- Start background loading (don't await here) ---
                const loadUserDataInBackground = async () => {
                    console.log("checkUserSession (async task): Starting user data load...");
                    if (!userProfile || userProfile.user_id !== currentUser.id) {
                        console.log("checkUserSession (async task): Loading profile...");
                        try {
                            // Use a timeout for profile fetching to prevent indefinite hangs? Optional.
                            userProfile = await getUserProfile(currentUser.id); // Still await here within the async task
                            if (userProfile) {
                                console.log("checkUserSession (async task): Profile loaded:", userProfile.username);
                                // If profile screen is active when data arrives, re-render it
                                if (currentScreen === 'profile') {
                                    renderProfile(userProfile);
                                }
                            } else {
                                console.warn("checkUserSession (async task): Profile fetch returned null/empty.");
                                // Handle case where user exists but profile is missing
                                if (currentScreen === 'profile') {
                                     // Show minimal info or setup prompt on profile screen
                                     profileContent.innerHTML = `<p class="p-2 text-center">Profile setup needed. Email: ${currentUser?.email || 'N/A'}</p>`;
                                     showElement(profileContent); hideElement(profileLoader);
                                }
                            }
                        } catch (profileError) {
                             console.error("checkUserSession (async task): Error loading profile:", profileError);
                             userProfile = null; // Ensure profile is null on error
                        }
                    } else {
                         console.log("checkUserSession (async task): Profile already cached.");
                    }

                    // Fetch games if we landed on the main screen
                    if (currentScreen === 'main') {
                        console.log("checkUserSession (async task): Fetching games for main screen...");
                        fetchGames();
                    }
                    console.log("checkUserSession (async task): Background data load attempt finished.");
                };
                // Fire off the background loading task
                loadUserDataInBackground();
                // --- End background loading ---

                // --- Handle navigation immediately (synchronously) ---
                if (currentScreen === 'auth' || currentScreen === 'loading') {
                    console.log("checkUserSession: Navigating to 'main' screen immediately...");
                    navigateTo('main'); // Navigate now, data will load in background
                    // Note: fetchGames is now called from loadUserDataInBackground *if* currentScreen is 'main'
                } else {
                     console.log(`checkUserSession: Already on screen '${currentScreen}', no immediate navigation needed.`);
                }

            } else {
                // No currentUser object (no active session)
                console.log("checkUserSession: No currentUser object. Ensuring auth screen.");
                // Don't call handleLogout here, onAuthStateChange handles SIGNED_OUT event.
                // Just navigate if not already on auth.
                if (currentScreen !== 'auth') {
                    navigateTo('auth');
                }
                // Reset auth form potentially?
                authForm.reset();
                authError.textContent = '';
            }
            console.log("checkUserSession: Check finished.");
        };

        // --- EVENT HANDLERS ---
        function handleGameItemClick(gameId) {
            console.log("Clicked game:", gameId);
            currentGameId = gameId; // Set current game ID
             // Navigate first to show loading state quickly if needed
            navigateTo('detail');
             // Fetch details, which will handle further navigation/rendering based on game status
            fetchGameDetails(gameId);
        }
        function handleCreateGameSubmit(e) {
            e.preventDefault();
            const location = document.getElementById('game-location').value;
            const datetime = document.getElementById('game-datetime').value;
            const submitButton = e.target.querySelector('button[type="submit"]');
            createGameError.textContent = ''; // Clear previous errors
            disableElement(submitButton);

            createGame(location, datetime).then(({data, error}) => {
                enableElement(submitButton); // Re-enable button
                if (error) {
                    console.error("Create game submit error:", error);
                    createGameError.textContent = error.message || "Failed to create game.";
                } else {
                    console.log("Game created successfully:", data);
                    toggleCreateGameModal(false); // Close modal
                    // Optionally navigate to the new game's detail screen?
                    // handleGameItemClick(data.id);
                    // Or just refresh the list (will happen via realtime anyway)
                    if (currentScreen === 'main') {
                        fetchGames(); // Trigger manual refresh for faster UI update?
                    }
                }
            });
        }
        function handleJoinLeaveClick() {
            if (!currentGameId || !currentGameData || currentGameData.status !== 'pending') return; // Only for pending games
            const action = joinLeaveGameBtn.textContent.trim();
            if (action === 'Join Game') {
                 joinGame(currentGameId);
            } else if (action === 'Leave Game') {
                 // Add confirmation for leaving
                 if (confirm("Are you sure you want to leave this game?")) {
                     leaveGame(currentGameId);
                 }
            }
        }
        function handleBeginGameClick() {
            if (!currentGameId || !currentGameData || currentGameData.status !== 'pending') return;
            const players = currentGameData.players || [];
            // Confirmation message includes player count check
            if (confirm(`Start the game with ${players.length} players? (Requires ${MIN_PLAYERS_TO_START})`)) {
                beginGame(currentGameId);
            }
        }
        function handleCancelGameClick() {
            if (!currentGameId || !currentGameData || currentGameData.status !== 'pending') return;
            // Confirmation is handled within cancelGame function
            cancelGame(currentGameId);
        }
        function handleScoreClick(e) {
            // Only trigger if the clicked element *is* a score div
            if (e.target.matches('.score')) {
                const team = e.target.dataset.team; // Get 'A' or 'B' from data-team attribute
                if (team) {
                    proposeScore(team);
                }
            }
        }
        function handleProfileUpdate(e) {
            e.preventDefault();
            const newUsername = editProfileUsernameInput.value.trim();
            const newCity = editProfileCityInput.value.trim();
            const newState = editProfileStateInput.value.trim();
            const newCountry = editProfileCountryInput.value.trim();
            profileUpdateError.textContent = ''; profileUpdateMessage.textContent = '';

            if (!newUsername || newUsername.length < 3) {
                 profileUpdateError.textContent = "Username must be at least 3 characters."; return;
            }

            // Build the update payload only with changed values
            const updates = {};
            if (userProfile && newUsername !== userProfile.username) updates.username = newUsername;
            if (userProfile && newCity !== (userProfile.city || '')) updates.city = newCity || null; // Use null if cleared
            if (userProfile && newState !== (userProfile.state || '')) updates.state = newState || null;
            if (userProfile && newCountry !== (userProfile.country || '')) updates.country = newCountry || null;

            if (Object.keys(updates).length === 0) {
                // No changes detected
                toggleProfileEdit(false); // Just switch back to display mode
                return;
            }

            disableElement(saveProfileBtn);
            updateUserProfile(currentUser.id, updates).then(({data, error}) => {
                enableElement(saveProfileBtn);
                if (error) {
                    console.error("Profile update error:", error);
                    profileUpdateError.textContent = `Update failed: ${error.message}`;
                    // Check for specific errors like username taken
                    if (error.code === '23505' && error.message.includes('profiles_username_key')) {
                         profileUpdateError.textContent = "Update failed: That username is already taken.";
                    }
                } else {
                    userProfile = data; // Update local profile cache
                    renderProfile(userProfile); // Re-render profile with new data
                    profileUpdateMessage.textContent = "Profile updated successfully!";
                    toggleProfileEdit(false); // Switch back to display mode
                    setTimeout(() => { profileUpdateMessage.textContent = ''; }, 3000); // Clear success message
                }
            });
        }
        function handleSendChat(e) {
            e.preventDefault(); // Prevent form submission if wrapped in form
            const msg = chatInput.value;
            sendChatMessage(msg); // Call the async chat send function
        }
        function handleLeaderboardFilterClick(e) {
            if (!e.target.matches('#leaderboard-filters button')) return;
            const scope = e.target.dataset.scope;
            // Update active button style
            leaderboardFilters.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            // Fetch leaderboard for the selected scope
            fetchLeaderboard(scope);
        }
        // General Back Button Handler
        function handleBackButtonClick() {
            // Default back action is usually to main screen
            if (currentScreen === 'profile' || currentScreen === 'leaderboard' || currentScreen === 'detail') {
                 navigateTo('main');
                 fetchGames(); // Refresh game list when going back
            } else {
                 // Define other back behaviors if needed
                 console.warn(`Back button clicked on unhandled screen: ${currentScreen}`);
            }
        }

        // --- UI TOGGLES AND HELPERS ---
        function toggleCreateGameModal(show) {
            if (show) {
                createGameModal.classList.add('visible');
                document.getElementById('game-location').focus(); // Focus first field
                 // Set min date/time to now for datetime-local input
                const now = new Date();
                now.setMinutes(now.getMinutes() - now.getTimezoneOffset()); // Adjust for timezone
                now.setSeconds(0); // Optional: zero out seconds
                now.setMilliseconds(0); // Optional: zero out ms
                document.getElementById('game-datetime').min = now.toISOString().slice(0,16);

            } else {
                createGameModal.classList.remove('visible');
                createGameForm.reset(); // Reset form fields
                createGameError.textContent = ''; // Clear errors
            }
        }
        function toggleProfileEdit(editing) {
            if (editing) {
                 hideElement(profileUsernameDisplay); // Hide static username display
                 hideElement(editProfileBtn); // Hide edit icon
                 showElement(profileEditFields); // Show input fields
                 showElement(saveProfileBtn); // Show save button
                 editProfileUsernameInput.focus(); // Focus username input
                 profileUpdateError.textContent = ''; // Clear messages
                 profileUpdateMessage.textContent = '';
            } else {
                 showElement(profileUsernameDisplay); // Show static username display
                 showElement(editProfileBtn); // Show edit icon
                 hideElement(profileEditFields); // Hide input fields
                 hideElement(saveProfileBtn); // Hide save button
                 profileUpdateError.textContent = ''; // Clear messages on exiting edit mode too
                 profileUpdateMessage.textContent = '';
            }
        }
        function toggleChatDrawer(open) {
            if (open) {
                chatDrawer.classList.add('open');
                // Update chat title based on context (e.g., game name) if needed
                 if (currentGameData && ['detail', 'active'].includes(currentScreen)) {
                    document.getElementById('chat-title').textContent = `${currentGameData.location_name || 'Game'} Chat`;
                 } else {
                    document.getElementById('chat-title').textContent = 'Chat'; // Default title
                 }
                scrollToChatBottom(); // Scroll on open
            } else {
                chatDrawer.classList.remove('open');
            }
        }
        function scrollToChatBottom() {
            // Use requestAnimationFrame for smoother scrolling after DOM updates
            requestAnimationFrame(() => {
                 if (chatMessages) {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                 }
            });
        }
        function showShareModal(text, url) {
            const shareUrl = url || window.location.href; // Default to current page URL
            const shareText = text || "Check out this game on HoopsLink!";
            shareLinkInput.value = shareUrl; // Set input value for copying

            // Web Share API check
            if (navigator.share) {
                 showElement(webShareApiBtn);
                 webShareApiBtn.onclick = async () => {
                     try {
                         await navigator.share({
                             title: 'HoopsLink Game', // Title for share dialog
                             text: shareText,
                             url: shareUrl
                         });
                         console.log('Content shared successfully');
                         toggleShareModal(false); // Close modal after successful share
                     } catch (err) {
                          console.error('Error sharing content:', err);
                          // Handle errors (e.g., user cancelled share) gracefully
                          if (err.name !== 'AbortError') {
                                alert(`Could not share: ${err.message}`);
                          }
                     }
                 };
            } else {
                 hideElement(webShareApiBtn); // Hide if Web Share API not supported
            }

            shareModal.classList.add('visible'); // Show the modal
        }
        function toggleShareModal(show) {
            if (show) {
                shareModal.classList.add('visible');
            } else {
                shareModal.classList.remove('visible');
                copyShareLinkBtn.textContent = 'Copy Link'; // Reset copy button text
            }
        }
        function copyShareLink() {
            shareLinkInput.select(); // Select the text
            shareLinkInput.setSelectionRange(0, 99999); // For mobile devices

            try {
                 // Use modern Clipboard API if available (requires HTTPS or localhost)
                 navigator.clipboard.writeText(shareLinkInput.value).then(() => {
                     copyShareLinkBtn.textContent = 'Copied!';
                     setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
                 }).catch(err => {
                     console.warn('Clipboard API failed, using fallback:', err);
                     oldCopyFallback(); // Use fallback if Clipboard API fails
                 });
            } catch (err) {
                 console.warn('Clipboard API not available, using fallback:', err);
                 oldCopyFallback(); // Use fallback if Clipboard API doesn't exist
            }
        }
        function oldCopyFallback() {
             // Deprecated fallback using execCommand
             try {
                 const successful = document.execCommand('copy');
                 if (successful) {
                     copyShareLinkBtn.textContent = 'Copied!';
                 } else {
                     copyShareLinkBtn.textContent = 'Copy Failed';
                 }
                 setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
             } catch (err) {
                 console.error('Fallback copy method failed:', err);
                 copyShareLinkBtn.textContent = 'Copy Error';
                 setTimeout(() => { copyShareLinkBtn.textContent = 'Copy Link'; }, 2000);
             }
         }

        // --- GAME TIMER FUNCTIONS ---
        function startGameTimer(endTimeString) {
            stopGameTimer(); // Clear any existing timer first
            if (!endTimeString || !gameTimerDisplay) return; // No end time or display element

            const endTime = new Date(endTimeString).getTime();
            if (isNaN(endTime) || endTime <= Date.now()) {
                 // End time is invalid or already passed
                 if (endTime <= Date.now() && currentGameData?.status === 'active') {
                    console.log("Timer started with time already expired.");
                    gameTimerDisplay.textContent = "00:00";
                    handleTimeExpired(); // Immediately trigger expiration logic if active
                 } else {
                     gameTimerDisplay.textContent = "--:--";
                 }
                 return;
            }

            console.log("Starting game timer, ends at:", new Date(endTimeString));

            gameTimerInterval = setInterval(() => {
                 const now = Date.now();
                 const remainingMilliseconds = endTime - now;

                 if (remainingMilliseconds <= 0) {
                     // Time is up
                     gameTimerDisplay.textContent = "00:00";
                     handleTimeExpired(); // Call function to handle game end by time
                 } else {
                     // Update display
                     updateTimerDisplay(remainingMilliseconds);
                 }
             }, 1000); // Update every second

            // Initial display update
            updateTimerDisplay(endTime - Date.now());
        }
        function stopGameTimer() {
            if (gameTimerInterval) {
                 clearInterval(gameTimerInterval);
                 gameTimerInterval = null;
                 console.log("Game timer stopped.");
            }
             // Reset display when timer stops (optional)
            if (gameTimerDisplay) {
                // gameTimerDisplay.textContent = "--:--";
            }
        }
        function updateTimerDisplay(milliseconds) {
            if (!gameTimerDisplay) return;
            const totalSeconds = Math.max(0, Math.floor(milliseconds / 1000));
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            // Format as MM:SS
            gameTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function handleTimeExpired() {
             stopGameTimer(); // Ensure interval is cleared
             console.log("Game time has expired!");

             // Check if the game is still active before ending it
             // Use currentGameData which should be updated by realtime
             if (currentGameData && currentGameData.status === 'active') {
                  console.log("Ending game due to time running out...");
                  // The endGame function will determine the winner based on current score
                  endGame(currentGameData);
             } else {
                  console.warn("Time expired, but game is not active or data unavailable. Status:", currentGameData?.status);
             }
         }

        // --- CONFETTI LOGIC --- (No changes needed from original)
        let confettiInterval = null; function startConfetti() { stopConfetti(); confettiContainer.innerHTML = ''; const colors = [varToString('--primary-color'), varToString('--secondary-color'), varToString('--accent-color'), '#FFFFFF']; for (let i = 0; i < 50; i++) createConfettiParticle(colors); confettiInterval = setInterval(() => { if (currentScreen !== 'end') { stopConfetti(); return; } createConfettiParticle(colors); }, 150); } function createConfettiParticle(colors) { const c=document.createElement('div');c.classList.add('confetti');c.style.left=`${Math.random()*100}vw`;c.style.backgroundColor=colors[Math.floor(Math.random()*colors.length)];c.style.animationDuration=`${Math.random()*2+3}s`;c.style.opacity=`${Math.random()*0.5+0.5}`;const s=Math.random()*0.5+0.5;c.style.transform=`scale(${s})`;c.style.width=`${10*s}px`;c.style.height=`${20*s}px`;confettiContainer.appendChild(c);c.addEventListener('animationend',()=>c.remove()); } function stopConfetti() { clearInterval(confettiInterval); confettiInterval = null; confettiContainer.innerHTML = ''; } function varToString(v) { try { if (document.documentElement) return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); } catch (e) { /* ignore error during init? */ } return '#FF6B00'; } // Default fallback

        // --- INITIALIZATION ---
        function initApp() {
             console.log("Initializing HoopsLink App...");
             if (!supabase) {
                 console.error("Supabase client failed to initialize. Application cannot start.");
                 hideElement(screens.loading);
                 // Show a critical error message on the auth screen maybe
                 authTitle.textContent = "Initialization Error";
                 authError.textContent = "Failed to connect to the database. Please refresh or contact support.";
                 disableElement(authSubmitBtn); disableElement(authToggleBtn);
                 navigateTo('auth'); // Show auth screen with error
                 return;
             }

             // --- EVENT LISTENERS ---
             authForm.addEventListener('submit', handleAuth);
             authToggleBtn.addEventListener('click', toggleAuthMode);
             logoutBtn.addEventListener('click', handleLogout);
             createGameFab.addEventListener('click', () => toggleCreateGameModal(true));
             createGameForm.addEventListener('submit', handleCreateGameSubmit);
             document.querySelector('#create-game-modal .modal-close-btn').addEventListener('click', () => toggleCreateGameModal(false)); // Close modal button

             joinLeaveGameBtn.addEventListener('click', handleJoinLeaveClick);
             beginGameBtn.addEventListener('click', handleBeginGameClick);
             cancelGameBtn.addEventListener('click', handleCancelGameClick);
             shareGameBtn.addEventListener('click', () => {
                 if (currentGameData) {
                    const text = `Join "${currentGameData.location_name || 'Game'}" on HoopsLink! Status: ${currentGameData.status}`;
                    // Consider generating a unique game URL later: const url = `${window.location.origin}?game=${currentGameData.id}`;
                    showShareModal(text, window.location.href);
                 }
             });
             document.querySelector('#share-modal .modal-close-btn').addEventListener('click', () => toggleShareModal(false));
             copyShareLinkBtn.addEventListener('click', copyShareLink);

             activeGameContent.addEventListener('click', handleScoreClick); // Listener on parent for score clicks
             confirmScoreBtn.addEventListener('click', confirmScoreProposal);
             rejectScoreBtn.addEventListener('click', rejectScoreProposal);

             profileNavBtn.addEventListener('click', () => {
                 if (currentUser) { navigateTo('profile'); fetchProfileData(currentUser.id); }
                 else { navigateTo('auth'); } // Redirect to login if not logged in
             });
             leaderboardNavBtn.addEventListener('click', () => {
                 navigateTo('leaderboard'); fetchLeaderboard('global'); // Default to global
             });
             editProfileBtn.addEventListener('click', () => toggleProfileEdit(true));
             saveProfileBtn.addEventListener('click', handleProfileUpdate); // Use click for save button too
             // profileEditFields.addEventListener('submit', handleProfileUpdate); // If using a form for edit fields

             leaderboardFilters.addEventListener('click', handleLeaderboardFilterClick); // Listener on parent
             // Add listener for all back buttons
             backBtns.forEach(btn => btn.addEventListener('click', handleBackButtonClick));

             toggleChatBtn.addEventListener('click', () => toggleChatDrawer(true));
             activeGameToggleChatBtn.addEventListener('click', () => toggleChatDrawer(true));
             closeChatBtn.addEventListener('click', () => toggleChatDrawer(false));
             sendChatBtn.addEventListener('click', handleSendChat);
             chatInput.addEventListener('keypress', (e) => {
                 // Send on Enter key, unless Shift+Enter is pressed (for newline)
                 if (e.key === 'Enter' && !e.shiftKey) {
                     e.preventDefault(); // Prevent default newline behavior
                     handleSendChat(e);
                 }
             });

             // Auth State Change Listener (Handles login, logout, token refresh)
                            supabase.auth.onAuthStateChange(async (event, session) => { // Listener itself can remain async if needed elsewhere
            console.log(`onAuthStateChange: Event: ${event}, Session: ${session ? `Active (User: ${session.user?.id})` : 'None'}`);
            const previousUserId = currentUser?.id;
            currentUser = session?.user ?? null; // Update global currentUser state

            switch (event) {
                case 'INITIAL_SESSION':
                case 'SIGNED_IN': // Treat initial session and sign-in similarly for this logic
                    console.log(`onAuthStateChange: ${event} detected. Calling checkUserSession.`);
                    // Call the SYNCHRONOUS checkUserSession. It hides the loader immediately.
                    checkUserSession();
                    // No need to await, and no need to hide loader here (it's done inside checkUserSession)
                    break;

                // ... Keep other cases (SIGNED_OUT, TOKEN_REFRESHED, etc.) as they were ...

                case 'SIGNED_OUT':
                    console.log("onAuthStateChange: SIGNED_OUT detected.");
                    if (currentScreen !== 'auth') {
                        handleLogout(); // Use the full logout procedure which also navigates and hides loader
                    } else {
                         // Already on auth screen, ensure loader is hidden if somehow visible
                         hideElement(screens.loading);
                         authForm.reset();
                         authError.textContent = '';
                    }
                    break;

                // ... rest of the switch cases ...

            }
        });

             // Initial session check after listeners are set up
             // checkUserSession is called by the INITIAL_SESSION event from onAuthStateChange
             // But call it manually just in case the listener fires late or edge cases.
            // checkUserSession();

        } // End initApp

        // --- START THE APP ---
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
